/*
 * [The "BSD license"]
 *  Copyright (c) 2015 Dan McLaughlin, Mike Lischke
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *  1. Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *  3. The name of the author may not be used to endorse or promote products
 *     derived from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

import "Files.stg" // All file specific stuff.

cppTypeInitMap ::= [
    "int":"0",
    "long":"0",
    "float":"0.0f",
    "double":"0.0",
    "bool":"false",
    "short":"0",
    "char":"0",
    default: "nullptr" // anything other than a primitive type is an object
]

LexerHeader(lexer, atn, actionFuncs, sempredFuncs, superClass = {antlr4::Lexer}) ::= <<
<namedActions.context>

class <file.exportMacro> <lexer.name> : public <superClass> {
public:
<if (lexer.tokens)>
  enum {
    <lexer.tokens: {k | <k> = <lexer.tokens.(k)>}; separator=", ", wrap, anchor>
  };
<endif>

<if (lexer.channels)>
  enum {
    <lexer.channels: {k | <k> = <lexer.channels.(k)>}; separator=", ", wrap, anchor>
  };
<endif>

<if (rest(lexer.modes))>
  enum {
    <rest(lexer.modes): {m | <m> = <i>,}; separator="\n", anchor>
  };
<endif>

  <lexer.name>(antlr4::CharStream *input);
  ~<lexer.name>();

  <namedActions.members>
  virtual std::string getGrammarFileName() const override;
  virtual const std::vector\<std::string>& getRuleNames() const override;

  virtual const std::vector\<std::string>& getModeNames() const override;
  virtual const std::vector\<std::string>& getTokenNames() const override; // deprecated, use vocabulary instead
  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;

  virtual const std::vector\<uint16_t> getSerializedATN() const override;
  virtual const antlr4::atn::ATN& getATN() const override;

  <if (actionFuncs)>
  virtual void action(antlr4::RuleContext *context, size_t ruleIndex, size_t actionIndex) override;
  <endif>
  <if (sempredFuncs)>
  virtual bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;
  <endif>

private:
  static std::vector\<antlr4::dfa::DFA> _decisionToDFA;
  static antlr4::atn::PredictionContextCache _sharedContextCache;
  static std::vector\<std::string> _ruleNames;
  static std::vector\<std::string> _tokenNames;
  static std::vector\<std::string> _modeNames;

  static std::vector\<std::string> _literalNames;
  static std::vector\<std::string> _symbolicNames;
  static antlr4::dfa::Vocabulary _vocabulary;
  <atn>

  <namedActions.declarations>

  // Individual action functions triggered by action() above.
  <actionFuncs.values; separator="\n">

  // Individual semantic predicate functions triggered by sempred() above.
  <sempredFuncs.values; separator="\n">

  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Lexer(lexer, atn, actionFuncs, sempredFuncs, superClass = {Lexer}) ::= <<
<lexer.name>::<lexer.name>(CharStream *input) : <superClass>(input) {
  _interpreter = new atn::LexerATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

<lexer.name>::~<lexer.name>() {
  delete _interpreter;
}

std::string <lexer.name>::getGrammarFileName() const {
  return "<lexer.grammarFileName>";
}

const std::vector\<std::string>& <lexer.name>::getRuleNames() const {
  return _ruleNames;
}

const std::vector\<std::string>& <lexer.name>::getModeNames() const {
  return _modeNames;
}

const std::vector\<std::string>& <lexer.name>::getTokenNames() const {
  return _tokenNames;
}

dfa::Vocabulary& <lexer.name>::getVocabulary() const {
  return _vocabulary;
}

const std::vector\<uint16_t> <lexer.name>::getSerializedATN() const {
  return _serializedATN;
}

const atn::ATN& <lexer.name>::getATN() const {
  return _atn;
}

<namedActions.definitions>

<if (actionFuncs)>
void <lexer.name>::action(RuleContext *context, size_t ruleIndex, size_t actionIndex) {
  switch (ruleIndex) {
    <lexer.actionFuncs.values: {f | case <f.ruleIndex>: <f.name>Action(dynamic_cast\<<f.ctxType> *>(context), actionIndex); break;}; separator="\n">

  default:
    break;
  }
}
<endif>

<if (sempredFuncs)>
bool <lexer.name>::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
    <lexer.sempredFuncs.values: {f | case <f.ruleIndex>: return <f.name>Sempred(dynamic_cast\<<f.ctxType> *>(context), predicateIndex);}; separator="\n">

  default:
    break;
  }
  return true;
}
<endif>

<actionFuncs.values; separator="\n">

<sempredFuncs.values; separator="\n">

// Static vars and initialization.
std::vector\<dfa::DFA> <lexer.name>::_decisionToDFA;
atn::PredictionContextCache <lexer.name>::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN <lexer.name>::_atn;
std::vector\<uint16_t> <lexer.name>::_serializedATN;

std::vector\<std::string> <lexer.name>::_ruleNames = {
  <lexer.ruleNames: {r | "<r>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::string> <lexer.name>::_modeNames = {
  <lexer.modes: {m | "<m>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::string> <lexer.name>::_literalNames = {
  <lexer.literalNames: {t | <t>}; null = "\"\"", separator = ", ", wrap, anchor>
};

std::vector\<std::string> <lexer.name>::_symbolicNames = {
  <lexer.symbolicNames: {t | <t>}; null = "\"\"", separator = ", ", wrap, anchor>
};

dfa::Vocabulary <lexer.name>::_vocabulary(_literalNames, _symbolicNames);

std::vector\<std::string> <lexer.name>::_tokenNames;

<lexer.name>::Initializer::Initializer() {
  // This code could be in a static initializer lambda, but VS doesn't allow access to private class members from there.
	for (size_t i = 0; i \< _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("\<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  <atn>
}

<lexer.name>::Initializer <lexer.name>::_init;
>>

RuleActionFunctionHeader(r, actions) ::= <<
void <r.name>Action(<r.ctxType> *context, size_t actionIndex);
>>

RuleActionFunction(r, actions) ::= <<
void <r.factory.grammar.name>::<r.name>Action(<r.ctxType> *context, size_t actionIndex) {
  switch (actionIndex) {
    <actions: {index | case <index>: <actions.(index)> break;}; separator="\n">

  default:
    break;
  }
}

>>

RuleSempredFunctionHeader(r, actions) ::= <<
bool <r.name>Sempred(<r.ctxType> *_localctx, size_t predicateIndex);
>>

RuleSempredFunction(r, actions) ::= <<
<! Called for both lexer and parser. But only one of them is actually available. Testing for the parser directly
   generates a warning, however. So do the check via the factory instead. !>
bool <if (r.factory.g.lexer)><lexer.name><else><parser.name><endif>::<r.name>Sempred(<r.ctxType> *_localctx, size_t predicateIndex) {
  switch (predicateIndex) {
    <actions: {index | case <index>: return <actions.(index)>}; separator=";\n">;

  default:
    break;
  }
  return true;
}

>>

//--------------------------------------------------------------------------------------------------

ParserHeader(parser, funcs, atn, sempredFuncs, superClass = {antlr4::Parser}) ::= <<
<namedActions.context>

class <file.exportMacro> <parser.name> : public <superClass> {
public:
<if (parser.tokens)>
  enum {
    <parser.tokens: {k | <k> = <parser.tokens.(k)>}; separator=", ", wrap, anchor>
  };
<endif>

<if (parser.tokens)>
  enum {
    <parser.rules: {r | Rule<r.name; format="cap"> = <r.index>}; separator=", ", wrap, anchor>
  };
<endif>

  <parser.name>(antlr4::TokenStream *input);
  ~<parser.name>();

  virtual std::string getGrammarFileName() const override;
  virtual const antlr4::atn::ATN& getATN() const override { return _atn; };
  virtual const std::vector\<std::string>& getTokenNames() const override { return _tokenNames; }; // deprecated: use vocabulary instead.
  virtual const std::vector\<std::string>& getRuleNames() const override;
  virtual antlr4::dfa::Vocabulary& getVocabulary() const override;

  <namedActions.members>

  <parser.funcs: {f | class <f.name; format = "cap">Context;};  separator = "\n"> <! Forward declare context classes. !>

  <funcs; separator = "\n">

  <if (sempredFuncs)>
  virtual bool sempred(antlr4::RuleContext *_localctx, size_t ruleIndex, size_t predicateIndex) override;
  <sempredFuncs.values; separator = "\n">
  <endif>

private:
  static std::vector\<antlr4::dfa::DFA> _decisionToDFA;
  static antlr4::atn::PredictionContextCache _sharedContextCache;
  static std::vector\<std::string> _ruleNames;
  static std::vector\<std::string> _tokenNames;

  static std::vector\<std::string> _literalNames;
  static std::vector\<std::string> _symbolicNames;
  static antlr4::dfa::Vocabulary _vocabulary;
  <atn>

  <namedActions.declarations>

  struct Initializer {
    Initializer();
  };
  static Initializer _init;
};
>>

Parser(parser, funcs, atn, sempredFuncs, superClass = {Parser}) ::= <<
using namespace antlr4;

<parser.name>::<parser.name>(TokenStream *input) : <superClass>(input) {
  _interpreter = new atn::ParserATNSimulator(this, _atn, _decisionToDFA, _sharedContextCache);
}

<parser.name>::~<parser.name>() {
  delete _interpreter;
}

std::string <parser.name>::getGrammarFileName() const {
  return "<parser.grammarFileName>";
}

const std::vector\<std::string>& <parser.name>::getRuleNames() const {
  return _ruleNames;
}

dfa::Vocabulary& <parser.name>::getVocabulary() const {
  return _vocabulary;
}

<namedActions.definitions>

<funcs; separator = "\n\n">

<if (sempredFuncs)>
bool <parser.name>::sempred(RuleContext *context, size_t ruleIndex, size_t predicateIndex) {
  switch (ruleIndex) {
  <parser.sempredFuncs.values: {f |
  case <f.ruleIndex>: return <f.name>Sempred(dynamic_cast\<<f.ctxType> *>(context), predicateIndex);}; separator="\n">

  default:
    break;
  }
  return true;
}

<sempredFuncs.values; separator="\n"><endif>

// Static vars and initialization.
std::vector\<dfa::DFA> <parser.name>::_decisionToDFA;
atn::PredictionContextCache <parser.name>::_sharedContextCache;

// We own the ATN which in turn owns the ATN states.
atn::ATN <parser.name>::_atn;
std::vector\<uint16_t> <parser.name>::_serializedATN;

std::vector\<std::string> <parser.name>::_ruleNames = {
  <parser.ruleNames: {r | "<r>"}; separator = ", ", wrap, anchor>
};

std::vector\<std::string> <parser.name>::_literalNames = {
  <parser.literalNames: {t | <t>}; null = "\"\"", separator = ", ", wrap, anchor>
};

std::vector\<std::string> <parser.name>::_symbolicNames = {
  <parser.symbolicNames: {t | <t>}; null = "\"\"", separator = ", ", wrap, anchor>
};

dfa::Vocabulary <parser.name>::_vocabulary(_literalNames, _symbolicNames);

std::vector\<std::string> <parser.name>::_tokenNames;

<parser.name>::Initializer::Initializer() {
	for (size_t i = 0; i \< _symbolicNames.size(); ++i) {
		std::string name = _vocabulary.getLiteralName(i);
		if (name.empty()) {
			name = _vocabulary.getSymbolicName(i);
		}

		if (name.empty()) {
			_tokenNames.push_back("\<INVALID>");
		} else {
      _tokenNames.push_back(name);
    }
	}

  <atn>
}

<parser.name>::Initializer <parser.name>::_init;
>>

SerializedATNHeader(model) ::= <<
static antlr4::atn::ATN _atn;
static std::vector\<uint16_t> _serializedATN;
>>

// Constructs the serialized ATN and writes init code for static member vars.
SerializedATN(model) ::= <<
<if (rest(model.segments))>
<model.segments: {segment | static uint16_t serializedATNSegment<i0>[] = {
  <segment; wrap={<\n>   }>
\};}; separator="\n">

<model.segments: {segment | _serializedATN.insert(_serializedATN.end(), serializedATNSegment<i0>,
  serializedATNSegment<i0> + sizeof(serializedATNSegment<i0>) / sizeof(serializedATNSegment<i0>[0]));
}>

<else>
<! only one segment, can be inlined !>
_serializedATN = {
  <model.serialized; wrap = {<\n>}>
};
<endif>

atn::ATNDeserializer deserializer;
_atn = deserializer.deserialize(_serializedATN);

size_t count = _atn.getNumberOfDecisions();
_decisionToDFA.reserve(count);
for (size_t i = 0; i \< count; i++) { <! Rework class ATN to allow standard iterations. !>
  _decisionToDFA.emplace_back(_atn.getDecisionState(i), i);
}
>>

RuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><if (altLabelCtxs)><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n"><endif>
<currentRule.ctxType>* <currentRule.name>(<args; separator=",">);

>>

RuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble, exceptions) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator = "\n">
<parser.name>::<currentRule.ctxType>* <parser.name>::<currentRule.name>(<args; separator=",">) {
  <currentRule.ctxType> *_localctx = _tracker.createInstance\<<currentRule.ctxType>\>(_ctx, getState()<currentRule.args:{a | , <a.name>}>);
  enterRule(_localctx, <currentRule.startState>, <parser.name>::Rule<currentRule.name; format = "cap">);
  <namedActions.init>
  <locals; separator = "\n">

  auto onExit = finally([=] {
  <finallyAction>
    exitRule();
  });
  try {
<! TODO: untested !><if (currentRule.hasLookaheadBlock)>
    size_t alt;
    <endif>
    <code>
<! TODO: untested !>   <postamble; separator = "\n">
    <namedActions.after>
  }
  <if (exceptions)>
  <exceptions; separator="\n">
  <else>
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  <endif>

  return _localctx;
}
>>

LeftRecursiveRuleFunctionHeader(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<! TODO: untested !><altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">
<currentRule.ctxType>* <currentRule.name>(<currentRule.args; separator = ", ">);
<currentRule.ctxType>* <currentRule.name>(int precedence<currentRule.args: {a | , <a>}>);
>>

LeftRecursiveRuleFunction(currentRule, args, code, locals, ruleCtx, altLabelCtxs, namedActions, finallyAction, postamble) ::= <<
<ruleCtx>
<altLabelCtxs: {l | <altLabelCtxs.(l)>}; separator="\n">

<parser.name>::<currentRule.ctxType>* <parser.name>::<currentRule.name>(<currentRule.args; separator=", ">) {
<! TODO: currentRule.args untested !>   return <currentRule.name>(0<currentRule.args: {a | , <a.name>}>);
}

<parser.name>::<currentRule.ctxType>* <parser.name>::<currentRule.name>(int precedence<currentRule.args:{a | , <a>}>) {
  ParserRuleContext *parentContext = _ctx;
  size_t parentState = getState();
  <parser.name>::<currentRule.ctxType> *_localctx = _tracker.createInstance\<<currentRule.ctxType>\>(_ctx, parentState<currentRule.args: {a | , <a.name>}>);
  <parser.name>::<currentRule.ctxType> *previousContext = _localctx;
  size_t startState = <currentRule.startState>;
  enterRecursionRule(_localctx, <currentRule.startState>, <parser.name>::Rule<currentRule.name; format = "cap">, precedence);

    <namedActions.init>
<! TODO: untested !>    <locals; separator = "\n">

  auto onExit = finally([=] {
  <if (finallyAction)><finallyAction><endif>
    unrollRecursionContexts(parentContext);
  });
  try {
    <if (currentRule.hasLookaheadBlock)>size_t alt;<endif>
    <code>
<! TODO: untested !><postamble; separator = "\n">
    <namedActions.after>
  }
  catch (RecognitionException &e) {
    _errHandler->reportError(this, e);
    _localctx->exception = std::current_exception();
    _errHandler->recover(this, _localctx->exception);
  }
  return _localctx;
}
>>

StructDeclHeader(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= <<
class <file.exportMacro> <struct.name> : public <if (contextSuperClass)><contextSuperClass><else>antlr4::ParserRuleContext<endif><if(interfaces)>, <interfaces; separator=", "><endif> {
public:
  <attrs: {a | <a>;}; separator="\n">
  <if (ctorAttrs)><struct.name>(antlr4::ParserRuleContext *parent, size_t invokingState);<endif>
  <struct.name>(antlr4::ParserRuleContext *parent, size_t invokingState<ctorAttrs: {a | , <a>}>);
<if (struct.provideCopyFrom)> <! don't need copy unless we have subclasses !>
  <struct.name>() : antlr4::ParserRuleContext() { }
  void copyFrom(<struct.name> *context);
  using antlr4::ParserRuleContext::copyFrom;
<endif>

  virtual size_t getRuleIndex() const override;
  <getters: {g | <g>}; separator = "\n">

  <dispatchMethods; separator = "\n">
<! TODO: untested !> <extensionMembers; separator = "\n">
};

>>

StructDecl(struct, ctorAttrs, attrs, getters, dispatchMethods, interfaces, extensionMembers) ::= <<
//----------------- <struct.name> ------------------------------------------------------------------

<if (ctorAttrs)>
<parser.name>::<struct.name>::<struct.name>(ParserRuleContext *parent, size_t invokingState)
  : <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>(parent, invokingState) {
}
<endif>

<parser.name>::<struct.name>::<struct.name>(ParserRuleContext *parent, size_t invokingState<ctorAttrs: {a | , <a>}>)
  : <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>(parent, invokingState) {
  <struct.ctorAttrs: {a | this-><a.name> = <a.name>;}; separator="\n">
}

<getters: {g | <g>}; separator = "\n">

size_t <parser.name>::<struct.name>::getRuleIndex() const {
  return <parser.name>::Rule<struct.derivedFromName; format = "cap">;
}

<if (struct.provideCopyFrom)>
void <parser.name>::<struct.name>::copyFrom(<struct.name> *ctx) {
  <if (contextSuperClass)><contextSuperClass><else>ParserRuleContext<endif>::copyFrom(ctx);
  <struct.attrs: {a | this-><a.name> = ctx-><a.name>;}; separator = "\n">
}
<endif>
<dispatchMethods; separator = "\n\n">
<! TODO: untested !><extensionMembers; separator = "\n\n">

>>

AltLabelStructDeclHeader(struct, attrs, getters, dispatchMethods) ::= <<
class <file.exportMacro> <struct.name> : public <currentRule.name; format = "cap">Context {
public:
  <struct.name>(<currentRule.name; format = "cap">Context *ctx);

  <if (attrs)><attrs: {a | <a>}; separator = "\n"><endif>
  <getters: {g | <g>}; separator = "\n">
  <dispatchMethods; separator = "\n">
};

>>

AltLabelStructDecl(struct, attrs, getters, dispatchMethods) ::= <<
//----------------- <struct.name> ------------------------------------------------------------------

<! TODO: untested !><if (attrs)><attrs: {a | <a>}; separator = "\n"><endif>
<getters: {g | <g>}; separator = "\n">
<parser.name>::<struct.name>::<struct.name>(<currentRule.name; format = "cap">Context *ctx) { copyFrom(ctx); }

<dispatchMethods; separator="\n">
>>


CodeBlockForOuterMostAltHeader(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= "<! Required to exist, but unused. !>"
CodeBlockForOuterMostAlt(currentOuterMostAltCodeBlock, locals, preamble, ops) ::= <<
<if (currentOuterMostAltCodeBlock.altLabel)>
_localctx = dynamic_cast\<<currentRule.ctxType> *>(_tracker.createInstance\<<parser.name>::<currentOuterMostAltCodeBlock.altLabel; format = "cap">Context>(_localctx));
<endif>
enterOuterAlt(_localctx, <currentOuterMostAltCodeBlock.alt.altNum>);
<CodeBlockForAlt(currentAltCodeBlock = currentOuterMostAltCodeBlock, ...)>
>>

CodeBlockForAltHeader(currentAltCodeBlock, locals, preamble, ops) ::= "<! Required to exist, but unused. !>"
CodeBlockForAlt(currentAltCodeBlock, locals, preamble, ops) ::= <<
<! TODO: untested !><locals; separator = "\n">
<! TODO: untested !><preamble; separator = "\n">
<ops; separator = "\n">
>>

LL1AltBlockHeader(choice, preamble, alts, error) ::= "<! Required to exist, but unused. !>"
LL1AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<! TODO: untested !><if (choice.label)>LL1AltBlock(choice, preamble, alts, error) <labelref(choice.label)> = _input->LT(1);<endif>
<preamble; separator="\n">
switch (_input->LA(1)) {
  <choice.altLook, alts: {look, alt | <cases(ttypes = look)> {
  <alt>
  break;
\}
}; separator = "\n">
default:
  <error>
}
>>

LL1OptionalBlockHeader(choice, alts, error) ::= "<! Required but unused. !>"
LL1OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
switch (_input->LA(1)) {
  <choice.altLook, alts: {look, alt | <cases(ttypes = look)> {
  <alt>
  break;
\}
}; separator="\n">
default:
  <error>
}
>>

LL1OptionalBlockSingleAltHeader(choice, expr, alts, preamble, error, followExpr) ::= "<! Required but unused. !>"
LL1OptionalBlockSingleAlt(choice, expr, alts, preamble, error, followExpr) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);

<preamble; separator = "\n">
if (<expr>) {
  <alts; separator = "\n">
}
>>

LL1StarBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "<! Required but unused. !>"
LL1StarBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<preamble; separator="\n">
while (<loopExpr>) {
  <alts; separator="\n">
  setState(<choice.loopBackStateNumber>);
  _errHandler->sync(this);
  <iteration>
}
>>

LL1PlusBlockSingleAltHeader(choice, loopExpr, alts, preamble, iteration) ::= "<! Required but unused. !>"
LL1PlusBlockSingleAlt(choice, loopExpr, alts, preamble, iteration) ::= <<
setState(<choice.blockStartStateNumber>); <! alt block decision !>
_errHandler->sync(this);
<preamble; separator="\n">
do {
  <alts; separator="\n">
  setState(<choice.stateNumber>); <! loopback/exit decision !>
  _errHandler->sync(this);
  <iteration>
} while (<loopExpr>);
>>

// LL(*) stuff

AltBlockHeader(choice, preamble, alts, error) ::= "<! Unused but must be present. !>"
AltBlock(choice, preamble, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
<! TODO: untested !><if (choice.label)><labelref(choice.label)> = _input->LT(1);<endif>
<! TODO: untested !><preamble; separator = "\n">
switch (getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i>: {
  <alt>
  break;
\}
}; separator="\n">
}
>>

OptionalBlockHeader(choice, alts, error) ::= "<! Unused but must be present. !>"
OptionalBlock(choice, alts, error) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);

switch (getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx)) {
<alts: {alt | case <i><if (!choice.ast.greedy)> + 1<endif>: {
  <alt>
  break;
\}
}; separator = "\n">
}
>>

StarBlockHeader(choice, alts, sync, iteration) ::= "<! Unused but must be present. !>"
StarBlock(choice, alts, sync, iteration) ::= <<
setState(<choice.stateNumber>);
_errHandler->sync(this);
alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
while (alt != <choice.exitAlt> && alt != atn::ATN::INVALID_ALT_NUMBER) {
  if (alt == 1<if(!choice.ast.greedy)> + 1<endif>) {
    <iteration>
    <alts> <! should only be one !>
  }
  setState(<choice.loopBackStateNumber>);
  _errHandler->sync(this);
  alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
}
>>

PlusBlockHeader(choice, alts, error) ::= "<! Required to exist, but unused. !>"
PlusBlock(choice, alts, error) ::= <<
setState(<choice.blockStartStateNumber>); <! alt block decision !>
_errHandler->sync(this);
alt = 1<if(!choice.ast.greedy)> + 1<endif>;
do {
  switch (alt) {
    <alts: {alt | case <i><if (!choice.ast.greedy)> + 1<endif>: {
      <alt>
      break;
    \}
}; separator="\n">
  default:
    <error>
  }
  setState(<choice.loopBackStateNumber>); <! loopback/exit decision !>
  _errHandler->sync(this);
  alt = getInterpreter\<atn::ParserATNSimulator>()->adaptivePredict(_input, <choice.decision>, _ctx);
} while (alt != <choice.exitAlt> && alt != atn::ATN::INVALID_ALT_NUMBER);
>>

Sync(s) ::= "Sync(s) sync(<s.expecting.name>);"

ThrowNoViableAltHeader(t) ::= "<! Unused but must be present. !>"
ThrowNoViableAlt(t) ::= "throw NoViableAltException(this);"

TestSetInlineHeader(s) ::= "<! Required but unused. !>"
TestSetInline(s) ::= <<
<s.bitsets: {bits | <if (rest(rest(bits.ttypes)))><bitsetBitfieldComparison(s, bits)><else><bitsetInlineComparison(s, bits)><endif>}; separator=" || ">
>>

// Java language spec 15.19 - shift operators mask operands rather than overflow to 0... need range test
testShiftInRange(shiftAmount) ::= <<
((<shiftAmount> & ~ 0x3fULL) == 0)
>>

// produces smaller bytecode only when bits.ttypes contains more than two items
bitsetBitfieldComparison(s, bits) ::= <<
(<testShiftInRange({<offsetShift(s.varName, bits.shift)>})> &&
  ((1ULL \<\< <offsetShift(s.varName, bits.shift)>) & (<bits.ttypes: {ttype | (1ULL \<\< <offsetShift(ttype, bits.shift, true)>)}; separator = "\n  | ">)) != 0)
>>

isZero ::= [
  "0": true,
  default: false
]

offsetShift(shiftAmount, offset, prefix = false) ::= <%
<if (!isZero.(offset))>(<if (prefix)><parser.name>::<endif><shiftAmount> - <offset>)<else><if (prefix)><parser.name>::<endif><shiftAmount><endif>
%>

// produces more efficient bytecode when bits.ttypes contains at most two items
bitsetInlineComparison(s, bits) ::= <%
<bits.ttypes: {ttype | <s.varName> == <parser.name>::<ttype>}; separator = "\n\n|| ">
%>

cases(ttypes) ::= <<
<ttypes: {t | case <parser.name>::<t>:}; separator="\n">
>>

InvokeRuleHeader(r, argExprsChunks) ::= "InvokeRuleHeader"
InvokeRule(r, argExprsChunks) ::= <<
setState(<r.stateNumber>);
<if(r.labels)><r.labels: {l | <labelref(l)> = }><endif><r.name>(<if(r.ast.options.p)><r.ast.options.p><if(argExprsChunks)>,<endif><endif><argExprsChunks>);
>>

MatchTokenHeader(m) ::= "<! Required but unused. !>"
MatchToken(m) ::= <<
setState(<m.stateNumber>);
<if (m.labels)><m.labels: {l | <labelref(l)> = }><endif>match(<parser.name>::<m.name>);
>>

MatchSetHeader(m, expr, capture) ::= "<! Required but unused. !>"
MatchSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, false)>"

MatchNotSetHeader(m, expr, capture) ::= "<! Required but unused. !>"
MatchNotSet(m, expr, capture) ::= "<CommonSetStuff(m, expr, capture, true)>"

CommonSetStuff(m, expr, capture, invert) ::= <<
setState(<m.stateNumber>);
<if (m.labels)><m.labels: {l | <labelref(l)> = }>_input->LT(1);<endif>
<capture>
if (<if (invert)><m.varName> == 0 || <m.varName> == Token::EOF || <else>!<endif>(<expr>)) {
  <if (m.labels)><m.labels: {l | <labelref(l)> = }><endif>_errHandler->recoverInline(this);
}
else {
  _errHandler->reportMatch(this);
  consume();
}
>>

WildcardHeader(w) ::= "<! Required but unused. !>"
Wildcard(w) ::= <<
setState(<w.stateNumber>);
<if (w.labels)><w.labels: {l | <labelref(l)> = }><endif>matchWildcard();
>>

// ACTION STUFF

ActionHeader(a, foo, chunks) ::= "<chunks>"
Action(a, foo, chunks) ::= "<chunks>"

ArgAction(a, chunks) ::= "ArgAction(a, chunks) <chunks>"

SemPredHeader(p, chunks, failChunks) ::= "<! Required but unused. !>"
SemPred(p, chunks, failChunks) ::= <<
setState(<p.stateNumber>);

if (!(<chunks>)) throw FailedPredicateException(this, <p.predicate><if (failChunks)>, <failChunks><elseif (p.msg)>, <p.msg><endif>);
>>

ExceptionClauseHeader(e, catchArg, catchAction) ::= "<! Required but unused. !>"
ExceptionClause(e, catchArg, catchAction) ::= <<
catch (<catchArg>) {
  <catchAction>
}
>>

// Lexer actions are not associated with model objects.

LexerSkipCommand()  ::= "skip();"
LexerMoreCommand()  ::= "more();"
LexerPopModeCommand() ::= "popMode();"

LexerTypeCommand(arg, grammar)      ::= "type = <grammar.name>::<arg>;"
LexerChannelCommand(arg, grammar)   ::= "channel = <arg>;"
LexerModeCommand(arg, grammar)      ::= "mode = <grammar.name>Mode::<arg>;"
LexerPushModeCommand(arg, grammar)  ::= "pushMode(<grammar.name>Mode::<arg>);"

ActionTextHeader(t) ::= "<t.text>"
ActionText(t) ::= "<t.text>"

ActionTemplateHeader(t) ::= "<! Required but unused. !>"
ActionTemplate(t) ::= "<t.st>"

ArgRefHeader(t) ::= "<! Required but unused. !>"
ArgRef(a) ::= "_localctx-><a.name>"

LocalRefHeader(t) ::= "<! Required but unused. !>"
LocalRef(a) ::= "_localctx-><a.name>"

RetValueRefHeader(t) ::= "<! Required but unused. !>"
RetValueRef(a) ::= "_localctx-><a.name>"

QRetValueRefHeader(t) ::= "<! Required but unused. !>"
QRetValueRef(a) ::= "<ctx(a)>-><a.dict>-><a.name>"
/** How to translate $tokenLabel */

TokenRefHeader(t) ::= "<! Required but unused. !>"
TokenRef(t) ::= "<ctx(t)>-><t.name>"

LabelRefHeader(t) ::= "<! Required but unused. !>"
LabelRef(t) ::= "<ctx(t)>-><t.name>"

ListLabelRefHeader(t) ::= "<! Required but unused. !>"
ListLabelRef(t) ::= "<ctx(t)>-><ListLabelName(t.name)>"

SetAttrHeader(t) ::= "<! Required but unused. !>"
SetAttr(s,rhsChunks) ::= "<ctx(s)>-><s.name> = <rhsChunks>;"

InputSymbolType() ::= "<file.InputSymbolType; null = {Token}> *"

TokenPropertyRef_textHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_text(t) ::= <<(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getText() : "")>>

TokenPropertyRef_typeHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_type(t) ::= "(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getType() : 0)"

TokenPropertyRef_lineHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_line(t) ::= "(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getLine() : 0)"

TokenPropertyRef_posHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_pos(t) ::= "(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getCharPositionInLine() : 0)"

TokenPropertyRef_channelHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_channel(t) ::= "(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getChannel() : 0)"

TokenPropertyRef_indexHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_index(t) ::= "(<ctx(t)>-><t.label> != nullptr ? <ctx(t)>-><t.label>->getTokenIndex() : 0)"

TokenPropertyRef_intHeader(t) ::= "<! Required but unused. !>"
TokenPropertyRef_int(t) ::= "(<ctx(t)>-><t.label> != nullptr ? std::stoi(<ctx(t)>-><t.label>->getText()) : 0)"

RulePropertyRef_startHeader(r)  ::= "<! Required but unused. !>"
RulePropertyRef_start(r) ::= "(<ctx(r)>-><r.label> != nullptr ? (<ctx(r)>-><r.label>->start) : nullptr)"

RulePropertyRef_stopHeader(r)  ::= "<! Required but unused. !>"
RulePropertyRef_stop(r)  ::= "(<ctx(r)>-><r.label> != nullptr ? (<ctx(r)>-><r.label>->stop) : nullptr)"

RulePropertyRef_textHeader(r)  ::= "<! Required but unused. !>"
RulePropertyRef_text(r)  ::= "(<ctx(r)>-><r.label> != nullptr ? _input->getText(<ctx(r)>-><r.label>->start, <ctx(r)>-><r.label>->stop) : nullptr)"

RulePropertyRef_ctxHeader(r)   ::= "<! Required but unused. !>"
RulePropertyRef_ctx(r)   ::= "<ctx(r)>-><r.label>"

ThisRulePropertyRef_start(r) ::= "ThisRulePropertyRef_start(r) _localctx->start"
ThisRulePropertyRef_stop(r)  ::= "ThisRulePropertyRef_stop(r) _localctx->stop"

ThisRulePropertyRef_textHeader(r)  ::= "<! Required but unused. !>"
ThisRulePropertyRef_text(r)  ::= "_input->getText(_localctx->start, _input->LT(-1))"

ThisRulePropertyRef_ctxHeader(r)   ::= "<! Required but unused. !>"
ThisRulePropertyRef_ctx(r)   ::= "_localctx"

ThisRulePropertyRef_parserHeader(r)	 ::= "<! Required but unused. !>"
ThisRulePropertyRef_parser(r)	 ::= "this"

NonLocalAttrRef(s) ::= "NonLocalAttrRef(s) ((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name>"
SetNonLocalAttr(s, rhsChunks) ::=
  "SetNonLocalAttr(s, rhsChunks) ((<s.ruleName; format=\"cap\">Context)getInvokingContext(<s.ruleIndex>)).<s.name> = <rhsChunks>;"

AddToLabelListHeader(a) ::= "<! Required but unused. !>"
AddToLabelList(a) ::= <<
<ctx(a.label)>-><a.listName>.push_back(<labelref(a.label)>);
>>

TokenLabelType() ::= "<file.TokenLabelType; null = {Token}> *"

TokenDeclHeader(t) ::= "antlr4::<TokenLabelType()><t.name> = nullptr;"
TokenDecl(t) ::= "<! Variable Declaration !>"

TokenTypeDeclHeader(t) ::= "<! Local Variable !>"
TokenTypeDecl(t) ::= "size_t <t.name> = 0;"

TokenListDeclHeader(t) ::= "std::vector\<antlr4::Token *> <t.name>;"
TokenListDecl(t) ::= "<! Variable Declaration !>"

RuleContextDeclHeader(r) ::= "<parser.name>::<r.ctxName> *<r.name> = nullptr;"
RuleContextDecl(r) ::= "<! Variable Declaration !>"

RuleContextListDeclHeader(rdecl) ::= "std::vector\<<rdecl.ctxName> *> <rdecl.name>;"
RuleContextListDecl(rdecl) ::= "<! Variable Declaration !>"

ContextTokenGetterDeclHeader(t) ::= "antlr4::tree::TerminalNode *<t.name>();"
ContextTokenGetterDecl(t) ::= <<
tree::TerminalNode* <parser.name>::<t.ctx.name>::<t.name>() {
  return getToken(<parser.name>::<t.name>, 0);
}

>>

ContextTokenListGetterDeclHeader(t) ::= "std::vector\<antlr4::tree::TerminalNode *> <t.name>();"
ContextTokenListGetterDecl(t) ::= <<
std::vector\<tree::TerminalNode *> <parser.name>::<t.ctx.name>::<t.name>() {
  return getTokens(<parser.name>::<t.name>);
}

>>

ContextTokenListIndexedGetterDeclHeader(t) ::= "antlr4::tree::TerminalNode* <t.name>(size_t i);"
ContextTokenListIndexedGetterDecl(t)  ::= <<
tree::TerminalNode* <parser.name>::<t.ctx.name>::<t.name>(size_t i) {
  return getToken(<parser.name>::<t.name>, i);
}

>>

ContextRuleGetterDeclHeader(r) ::= "<r.ctxName> *<r.name>();"
ContextRuleGetterDecl(r) ::= <<
<! Note: ctxName is the name of the context to return, while ctx is the owning context. !>
<parser.name>::<r.ctxName>* <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContext\<<parser.name>::<r.ctxName>\>(0);
}

>>

ContextRuleListGetterDeclHeader(r) ::= "std::vector\<<r.ctxName> *> <r.name>();"
ContextRuleListGetterDecl(r) ::= <<
std::vector\<<parser.name>::<r.ctxName> *> <parser.name>::<r.ctx.name>::<r.name>() {
  return getRuleContexts\<<parser.name>::<r.ctxName>\>();
}

>>

ContextRuleListIndexedGetterDeclHeader(r) ::= "<r.ctxName>* <r.name>(size_t i);"
ContextRuleListIndexedGetterDecl(r) ::= <<
<parser.name>::<r.ctxName>* <parser.name>::<r.ctx.name>::<r.name>(size_t i) {
  return getRuleContext\<<parser.name>::<r.ctxName>\>(i);
}

>>

LexerRuleContext() ::= "antlr4::RuleContext"

// The rule context name is the rule followed by a suffix; e.g. r becomes rContext.
RuleContextNameSuffix() ::= "Context"

ImplicitTokenLabel(tokenName) ::= <<
<tokenName; format = "lower">Token
>>

ImplicitRuleLabel(ruleName) ::= "<ruleName>Context"
ImplicitSetLabel(id) ::= "_tset<id>"
ListLabelName(label) ::= "<label>"

CaptureNextToken(d) ::= "CaptureNextToken(d) <d.varName> = _input->LT(1);"

CaptureNextTokenTypeHeader(d) ::= "<! Required but unused. !>"
CaptureNextTokenType(d) ::= "<d.varName> = _input->LA(1);"

ListenerDispatchMethodHeader(method) ::= <<
virtual void <if (method.isEnter)>enter<else>exit<endif>Rule(antlr4::tree::ParseTreeListener *listener) override;
>>
ListenerDispatchMethod(method) ::= <<
void <parser.name>::<struct.name>::<if (method.isEnter)>enter<else>exit<endif>Rule(tree::ParseTreeListener *listener) {
  auto parserListener = dynamic_cast\<<parser.grammarName>Listener *>(listener);
  if (parserListener != nullptr)
    parserListener-><if(method.isEnter)>enter<else>exit<endif><struct.derivedFromName; format="cap">(this);
}
>>

VisitorDispatchMethodHeader(method) ::= <<

virtual antlrcpp::Any accept(antlr4::tree::ParseTreeVisitor *visitor) override;
>>
VisitorDispatchMethod(method) ::=  <<

antlrcpp::Any <parser.name>::<struct.name>::accept(tree::ParseTreeVisitor *visitor) {
  if (auto parserVisitor = dynamic_cast\<<parser.grammarName>Visitor*>(visitor))
    return parserVisitor->visit<struct.derivedFromName; format="cap">(this);
  else
    return visitor->visitChildren(this);
}
>>

AttributeDeclHeader(d) ::= "<d.type> <d.name><if(d.initValue)> = <d.initValue><endif>"
AttributeDecl(d) ::= "<d.type> <d.name>"

/** If we don't know location of label def x, use this template */
labelref(x) ::= "<if (!x.isLocal)>dynamic_cast\<<x.ctx.name> *>(_localctx)-><endif><x.name>"

/** For any action chunk, what is correctly-typed context struct ptr? */
ctx(actionChunk) ::= "dynamic_cast\<<actionChunk.ctx.name> *>(_localctx)"

// used for left-recursive rules
recRuleAltPredicate(ruleName,opPrec) ::= "precpred(_ctx, <opPrec>)"
recRuleSetReturnAction(src,name) ::= "recRuleSetReturnAction(src,name) $<name>=$<src>.<name>;"
recRuleSetStopToken() ::= "_ctx->stop = _input->LT(-1);"

recRuleAltStartAction(ruleName, ctxName, label) ::= <<
_localctx = _tracker.createInstance\<<ctxName>Context>(parentContext, parentState);
<if (label)>_localctx-><label> = previousContext;<endif>
pushNewRecursionContext(_localctx, startState, Rule<ruleName; format = "cap">);
>>

// Separate context variable to avoid frequent pointer type casts.
recRuleLabeledAltStartAction(ruleName, currentAltLabel, label, isListLabel) ::= <<
auto newContext = _tracker.createInstance\<<currentAltLabel; format = "cap">Context>(_tracker.createInstance\<<ruleName; format="cap">Context>(parentContext, parentState));
_localctx = newContext;
<if(label)>
<if(isListLabel)>
newContext-><label>.push_back(previousContext);
<else>
newContext-><label> = previousContext;
<endif>
<endif>
pushNewRecursionContext(newContext, startState, Rule<ruleName; format = "cap">);
>>

recRuleReplaceContext(ctxName) ::= <<
_localctx = _tracker.createInstance\<<ctxName>Context>(_localctx);
_ctx = _localctx;
previousContext = _localctx;
>>

recRuleSetPrevCtx() ::= <<
if (!_parseListeners.empty())
  triggerExitRuleEvent();
previousContext = _localctx;
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "null".
 */
initValue(typeName) ::= <<
<cppTypeInitMap.(typeName)>
>>

