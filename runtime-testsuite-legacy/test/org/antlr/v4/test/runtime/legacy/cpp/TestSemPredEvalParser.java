/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.legacy.cpp;

import org.junit.Test;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNull;

@SuppressWarnings("unused")
public class TestSemPredEvalParser extends BaseCppTest {

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void test2UnpredicatedAlts() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(374);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : {getInterpreter<atn::ParserATNSimulator>()->setPredictionMode(atn::PredictionMode::LL_EXACT_AMBIG_DETECTION);} a ';' a; // do 2x: once in ATN, next in DFA\n");
		grammarBuilder.append("a : ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  | {false}? ID {std::cout << \"alt 3\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x; y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, true);

		assertEquals(
			"alt 1\n" +
			"alt 1\n", found);

		assertEquals(
			"line 1:0 reportAttemptingFullContext d=0 (a), input='x'\n" +
			"line 1:0 reportAmbiguity d=0 (a): ambigAlts={1, 2}, input='x'\n" +
			"line 1:3 reportAttemptingFullContext d=0 (a), input='y'\n" +
			"line 1:3 reportAmbiguity d=0 (a): ambigAlts={1, 2}, input='y'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void test2UnpredicatedAltsAndOneOrthogonalAlt() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(439);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : {getInterpreter<atn::ParserATNSimulator>()->setPredictionMode(atn::PredictionMode::LL_EXACT_AMBIG_DETECTION);} a ';' a ';' a;\n");
		grammarBuilder.append("a : INT {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | ID {std::cout << \"alt 2\" << std::endl;} // must pick this one for ID since pred is false\n");
		grammarBuilder.append("  | ID {std::cout << \"alt 3\" << std::endl;}\n");
		grammarBuilder.append("  | {false}? ID {std::cout << \"alt 4\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="34; x; y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, true);

		assertEquals(
			"alt 1\n" +
			"alt 2\n" +
			"alt 2\n", found);

		assertEquals(
			"line 1:4 reportAttemptingFullContext d=0 (a), input='x'\n" +
			"line 1:4 reportAmbiguity d=0 (a): ambigAlts={2, 3}, input='x'\n" +
			"line 1:7 reportAttemptingFullContext d=0 (a), input='y'\n" +
			"line 1:7 reportAmbiguity d=0 (a): ambigAlts={2, 3}, input='y'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testActionHidesPreds() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(239);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {int i = 0;}\n");
		grammarBuilder.append("s : a+ ;\n");
		grammarBuilder.append("a : {i = 1;} ID {i == 1}? {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {i = 2;} ID {i == 2}? {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x x y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 1\n" +
			"alt 1\n" +
			"alt 1\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testActionsHidePredsInGlobalFOLLOW() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(316);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {\n");
		grammarBuilder.append("bool pred(bool v) {\n");
		grammarBuilder.append("	std::cout << \"eval=\" << std::boolalpha << v << std::endl;\n");
		grammarBuilder.append("	return v;\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("s : e {} {pred(true)}? {std::cout << \"parse\" << std::endl;} '!' ;\n");
		grammarBuilder.append("t : e {} {pred(false)}? ID ;\n");
		grammarBuilder.append("e : ID | ; // non-LL(1) so we use ATN\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a!";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"eval=true\n" +
			"parse\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testAtomWithClosureInTranslatedLRRule() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(94);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("start : e[0] EOF;\n");
		grammarBuilder.append("e[int _p]\n");
		grammarBuilder.append("    :   ( 'a' | 'b'+ ) ( {3 >= $_p}? '+' e[4] )*\n");
		grammarBuilder.append("    ;\n");
		String grammar = grammarBuilder.toString();


		String input ="a+b+a";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "start", input, false);

		assertEquals("", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testDepedentPredsInGlobalFOLLOW() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(343);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {\n");
		grammarBuilder.append("bool pred(bool v) {\n");
		grammarBuilder.append("	std::cout << \"eval=\" << std::boolalpha << v << std::endl;\n");
		grammarBuilder.append("	return v;\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("s : a[99] ;\n");
		grammarBuilder.append("a[int i] : e {pred($i == 99)}? {std::cout << \"parse\" << std::endl;} '!' ;\n");
		grammarBuilder.append("b[int i] : e {pred($i == 99)}? ID ;\n");
		grammarBuilder.append("e : ID | ; // non-LL(1) so we use ATN\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a!";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"eval=true\n" +
			"parse\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testDependentPredNotInOuterCtxShouldBeIgnored() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(300);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : b[2] ';' |  b[2] '.' ; // decision in s drills down to ctx-dependent pred in a;\n");
		grammarBuilder.append("b[int i] : a[i] ;\n");
		grammarBuilder.append("a[int i]\n");
		grammarBuilder.append("  : {$i == 1}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("    | {$i == 2}? ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("    ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;\n");
		String grammar = grammarBuilder.toString();


		String input ="a;";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("alt 2\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testDisabledAlternative() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(121);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("cppCompilationUnit : content+ EOF;\n");
		grammarBuilder.append("content: anything | {false}? .;\n");
		grammarBuilder.append("anything: ANY_CHAR;\n");
		grammarBuilder.append("ANY_CHAR: [_a-zA-Z0-9];");
		String grammar = grammarBuilder.toString();


		String input ="hello";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "cppCompilationUnit", input, false);

		assertEquals("", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testIndependentPredNotPassedOuterCtxToAvoidCastException() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(209);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : b ';' |  b '.' ;\n");
		grammarBuilder.append("b : a ;\n");
		grammarBuilder.append("a\n");
		grammarBuilder.append("  : {false}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}? ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append(" ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a;";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("alt 2\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testNoTruePredsThrowsNoViableAlt() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(197);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a a;\n");
		grammarBuilder.append("a : {false}? ID INT {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {false}? ID INT {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="y 3 x 4";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("", found);

		assertEquals("line 1:0 no viable alternative at input 'y'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testOrder() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(323);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a {} a; // do 2x: once in ATN, next in DFA;\n");
		grammarBuilder.append("// action blocks lookahead from falling off of 'a'\n");
		grammarBuilder.append("// and looking into 2nd 'a' ref. !ctx dependent pred\n");
		grammarBuilder.append("a : ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 1\n" +
			"alt 1\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredFromAltTestedInLoopBack_1() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(217);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("file_\n");
		grammarBuilder.append("@after {std::cout << $ctx->toStringTree(this) << std::endl;}\n");
		grammarBuilder.append("  : para para EOF ;\n");
		grammarBuilder.append("para: paraContent NL NL ;\n");
		grammarBuilder.append("paraContent : ('s'|'x'|{_input->LA(2) != TParser::NL}? NL)+ ;\n");
		grammarBuilder.append("NL : '\\n' ;\n");
		grammarBuilder.append("s : 's' ;\n");
		grammarBuilder.append("X : 'x' ;");
		String grammar = grammarBuilder.toString();


		String input =
			"s\n" +
			"\n" +
			"\n" +
			"x\n";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "file_", input, true);

		assertEquals("(file_ (para (paraContent s) \\n \\n) (para (paraContent \\n x \\n)) <EOF>)\n", found);

		assertEquals(
			"line 5:0 mismatched input '<EOF>' expecting '\n" +
			"'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredFromAltTestedInLoopBack_2() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(217);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("file_\n");
		grammarBuilder.append("@after {std::cout << $ctx->toStringTree(this) << std::endl;}\n");
		grammarBuilder.append("  : para para EOF ;\n");
		grammarBuilder.append("para: paraContent NL NL ;\n");
		grammarBuilder.append("paraContent : ('s'|'x'|{_input->LA(2) != TParser::NL}? NL)+ ;\n");
		grammarBuilder.append("NL : '\\n' ;\n");
		grammarBuilder.append("s : 's' ;\n");
		grammarBuilder.append("X : 'x' ;");
		String grammar = grammarBuilder.toString();


		String input =
			"s\n" +
			"\n" +
			"\n" +
			"x\n" +
			"\n";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "file_", input, true);

		assertEquals("(file_ (para (paraContent s) \\n \\n) (para (paraContent \\n x) \\n \\n) <EOF>)\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredTestedEvenWhenUnAmbig_1() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(230);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {bool enumKeyword = true;}\n");
		grammarBuilder.append("primary\n");
		grammarBuilder.append("    :   ID {std::cout << \"ID \"+$ID.text << std::endl;}\n");
		grammarBuilder.append("    |   {!enumKeyword}? 'enum' {std::cout << \"enum\" << std::endl;}\n");
		grammarBuilder.append("    ;\n");
		grammarBuilder.append("ID : [a-z]+ ;\n");
		grammarBuilder.append("WS : [ \\t\\n\\r]+ -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="abc";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "primary", input, false);

		assertEquals("ID abc\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredTestedEvenWhenUnAmbig_2() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(230);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {bool enumKeyword = true;}\n");
		grammarBuilder.append("primary\n");
		grammarBuilder.append("    :   ID {std::cout << \"ID \"+$ID.text << std::endl;}\n");
		grammarBuilder.append("    |   {!enumKeyword}? 'enum' {std::cout << \"enum\" << std::endl;}\n");
		grammarBuilder.append("    ;\n");
		grammarBuilder.append("ID : [a-z]+ ;\n");
		grammarBuilder.append("WS : [ \\t\\n\\r]+ -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="enum";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "primary", input, false);

		assertEquals("", found);

		assertEquals("line 1:0 no viable alternative at input 'enum'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredicateDependentOnArg() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(238);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {int i = 0;}\n");
		grammarBuilder.append("s : a[2] a[1];\n");
		grammarBuilder.append("a[int i]\n");
		grammarBuilder.append("  : {$i == 1}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {$i == 2}? ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a b";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 2\n" +
			"alt 1\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredicateDependentOnArg2() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(166);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {int i = 0;}\n");
		grammarBuilder.append("s : a[2] a[1];\n");
		grammarBuilder.append("a[int i]\n");
		grammarBuilder.append("  : {$i == 1}? ID \n");
		grammarBuilder.append("  | {$i == 2}? ID \n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a b";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testPredsInGlobalFOLLOW() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(310);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {\n");
		grammarBuilder.append("bool pred(bool v) {\n");
		grammarBuilder.append("	std::cout << \"eval=\" << std::boolalpha << v << std::endl;\n");
		grammarBuilder.append("	return v;\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("}\n");
		grammarBuilder.append("s : e {pred(true)}? {std::cout << \"parse\" << std::endl;} '!' ;\n");
		grammarBuilder.append("t : e {pred(false)}? ID ;\n");
		grammarBuilder.append("e : ID | ; // non-LL(1) so we use ATN\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="a!";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"eval=true\n" +
			"parse\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testRewindBeforePredEval() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(249);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a a;\n");
		grammarBuilder.append("a : {_input->LT(1)->getText() == \"x\"}? ID INT {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {_input->LT(1)->getText() == \"y\"}? ID INT {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="y 3 x 4";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 2\n" +
			"alt 1\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testSimple() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(295);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a a a; // do 3x: once in ATN, next in DFA then INT in ATN\n");
		grammarBuilder.append("a : {false}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  | INT         {std::cout << \"alt 3\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x y 3";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 2\n" +
			"alt 2\n" +
			"alt 3\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testSimpleValidate() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(190);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a ;\n");
		grammarBuilder.append("a : {false}? ID  {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  INT {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("", found);

		assertEquals("line 1:0 no viable alternative at input 'x'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testSimpleValidate2() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(193);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a a a;\n");
		grammarBuilder.append("a : {false}? ID  {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  INT {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="3 4 x";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 2\n" +
			"alt 2\n", found);

		assertEquals("line 1:4 no viable alternative at input 'x'\n", this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testToLeft() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(190);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("	s : a+ ;\n");
		grammarBuilder.append("a : {false}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x x y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"alt 2\n" +
			"alt 2\n" +
			"alt 2\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testToLeftWithVaryingPredicate() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(289);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("@parser::members {int i = 0;}\n");
		grammarBuilder.append("s : ({i += 1;\n");
		grammarBuilder.append("std::cout << \"i=\";\n");
		grammarBuilder.append("std::cout << i << std::endl;} a)+ ;\n");
		grammarBuilder.append("a : {i % 2 == 0}? ID {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {i % 2 != 0}? ID {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x x y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals(
			"i=1\n" +
			"alt 2\n" +
			"i=2\n" +
			"alt 1\n" +
			"i=3\n" +
			"alt 2\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testUnpredicatedPathsInAlt() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(209);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | b {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("a : {false}? ID INT\n");
		grammarBuilder.append("  | ID INT\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("b : ID ID\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x 4";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("alt 1\n", found);
		assertNull(this.stderrDuringParse);

	}

	/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
	@Test
	public void testValidateInDFA() throws Exception {
		mkdir(tmpdir);


		StringBuilder grammarBuilder = new StringBuilder(358);
		grammarBuilder.append("grammar T;\n");
		grammarBuilder.append("s : a ';' a;\n");
		grammarBuilder.append("// ';' helps us to resynchronize without consuming\n");
		grammarBuilder.append("// 2nd 'a' reference. We our testing that the DFA also\n");
		grammarBuilder.append("// throws an exception if the validating predicate fails\n");
		grammarBuilder.append("a : {false}? ID  {std::cout << \"alt 1\" << std::endl;}\n");
		grammarBuilder.append("  | {true}?  INT {std::cout << \"alt 2\" << std::endl;}\n");
		grammarBuilder.append("  ;\n");
		grammarBuilder.append("ID : 'a'..'z'+ ;\n");
		grammarBuilder.append("INT : '0'..'9'+;\n");
		grammarBuilder.append("WS : (' '|'\\n') -> skip ;");
		String grammar = grammarBuilder.toString();


		String input ="x ; y";
		String found = execParser("T.g4", grammar, "TParser", "TLexer", "TListener", "TVisitor", "s", input, false);

		assertEquals("", found);

		assertEquals(
			"line 1:0 no viable alternative at input 'x'\n" +
			"line 1:4 no viable alternative at input 'y'\n", this.stderrDuringParse);

	}


}
