IgnoredTests ::= [
	"Visitors.Basic": true,
	"Visitors.LR": true,
	"Visitors.LRWithLabels": true,
	"Visitors.RuleGetters_1": true,
	"Visitors.RuleGetters_2": true,
	"Visitors.TokenGetters_1": true,
	"Visitors.TokenGetters_2": true,
	default: false
]

TestFile(file) ::= <<
/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.go;

import org.junit.Ignore;
import org.junit.Test;

import static org.junit.Assert.*;

<if(file.Options.("ImportGrammar"))>
import org.antlr.v4.tool.Grammar;
<endif>

public class Test<file.name> extends BaseTest {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}<\n>
>>

LexerTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(parserpkgdir);
<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
	writeFile(parserpkgdir, "<grammar>.g4", slave_<grammar>);
	}; separator="\n">

<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>
	<test.afterGrammar>
	String input =<writeStringLiteral(test.Input)>;
	String found = execLexer("<grammar>.g4", grammar, "<grammar><if(test.Options.("CombinedGrammar"))>Lexer<endif>", input, <writeBoolean(test.Options.("ShowDFA"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}
>>


CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>

ParserTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(parserpkgdir);
<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
<if(test.Options.("SlaveIsLexer"))>
	rawGenerateAndBuildRecognizer("<grammar>.g4", slave_<grammar>, null, "<grammar>");
<else>
	writeFile(parserpkgdir, "<grammar>.g4", slave_<grammar>);
<endif>
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>
	<test.afterGrammar>
	String input =<writeStringLiteral(test.Input)>;
	String found = execParser("<grammar>.g4", grammar, "<grammar>Parser", "<grammar>Lexer",
		"<grammar>Listener", "<grammar>Visitor", "<test.Rule>", input, <writeBoolean(test.Options.("Debug"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}
>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, <test.debug>);
}

>>

ConcreteParserTestMethod(test) ::= <<
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

testAnnotations(test) ::= <%
@Test
<if(test.Options.("Timeout"))>
(timeout = <test.Options.("Timeout")>)
<endif>
<if(test.Options.("Ignore"))>
<\n>@Ignore(<writeStringLiteral(test.Options.("Ignore"))>)
<elseif(IgnoredTests.(({<file.name>.<test.name>})))>
<\n>@Ignore(<writeStringLiteral(IgnoredTests.(({<file.name>.<test.name>})))>)
<endif>
%>

buildStringLiteral(text, variable) ::= <<
StringBuilder <variable>Builder = new StringBuilder(<strlen.(text)>);
<lines.(text):{line|<variable>Builder.append("<escape.(line)>");}; separator="\n">
String <variable> = <variable>Builder.toString();
>>

writeStringLiteral(text) ::= <%
<if(isEmpty.(text))>
""
<else>
<writeLines(lines.(text))>
<endif>
%>

writeLines(textLines) ::= <%
<if(rest(textLines))>
<textLines:{line|
<\n>		"<escape.(line)>}; separator="\" +">"
<else>
"<escape.(first(textLines))>"
<endif>
%>

string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= <<fmt.Println(<s>)>>
write(s) ::= <<fmt.Print(<s>)>>
writeList(s) ::= <<fmt.Print(<s; separator="+">);>>

False() ::= "false"

True() ::= "true"

Not(v) ::= "!<v>"

Assert(s) ::= ""

Cast(t,v) ::= "(<v>)"

Append(a,b) ::= "<a> + fmt.Sprint(<b>)"

Concat(a,b) ::= "<a><b>"

DeclareLocal(s, v) ::= "var <s> = <v>"

AssertIsList(v) ::= ""

AssignLocal(s, v) ::= "<s> = <v>;"

InitIntMember(n, v) ::= <%var <n> int = <v>; var _ int = <n>; %>

InitBooleanMember(n, v) ::= <%var <n> bool = <v>; var _ bool = <n>; %>

GetMember(n) ::= <%<n>%>

SetMember(n, v) ::= <%<n> = <v>;%>

AddMember(n, v) ::= <%<n> += <v>;%>

PlusMember(v, n) ::= <%<v> + fmt.Sprint(<n>)%>

MemberEquals(n, v) ::= <%<n> == <v>%>

ModMemberEquals(n, m, v) ::= <%<n> % <m> == <v>%>

ModMemberNotEquals(n, m, v) ::= <%<n> % <m> != <v>%>

DumpDFA() ::= "p.DumpDFA()"

Pass() ::= ""

StringList() ::= "[]string"

BuildParseTrees() ::= "p.BuildParseTrees = true"

BailErrorStrategy() ::= <%p.SetErrorHandler(antlr.NewBailErrorStrategy())%>

ToStringTree(s) ::= <%<s>.ToStringTree(nil, p)%>

Column() ::= "p.GetCharPositionInLine()"

Text() ::= "l.GetText()"

ValEquals(a, b) ::= <%<a> == <b>%>

TextEquals(a) ::= <%p.GetText() == "<a>"%>

PlusText(a) ::= <%"<a>" + l.GetText()%>

InputText() ::= "p.GetTokenStream().GetAllText()"

LTEquals(i, v) ::= <%p.GetTokenStream().LT(<i>).GetText() == <v>%>

LANotEquals(i, v) ::= <%p.GetTokenStream().LA(<i>) != <v>%>

TokenStartColumnEquals(i) ::= <%p.TokenStartColumn == <i>%>

ImportListener(X) ::= ""

GetExpectedTokenNames() ::= "p.GetExpectedTokens().StringVerbose(p.GetTokenNames(), nil, false)"

RuleInvocationStack() ::= "antlr.PrintArrayJavaStyle(p.GetRuleInvocationStack(nil))"

LL_EXACT_AMBIG_DETECTION() ::= <<p.Interpreter.SetPredictionMode(antlr.PredictionModeLLExactAmbigDetection);>>

ParserToken(parser, token) ::= <%<parser><token>%>

Production(p) ::= <%<p; format="cap">%>

Result(r) ::= <%Get<r; format="cap">()%>

ParserPropertyMember() ::= <<
@parser::members {
func (p *TParser) Property() bool {
	return true
}
}
>>

ParserPropertyCall(p, call) ::= "<p>.<call>"

PositionAdjustingLexer() ::= <<
func (p *PositionAdjustingLexer) NextToken() antlr.Token {
	if _, ok := p.Interpreter.(*PositionAdjustingLexerATNSimulator); !ok {
		p.Interpreter = NewPositionAdjustingLexerATNSimulator(p, lexerAtn, p.Interpreter.DecisionToDFA(), p.Interpreter.SharedContextCache())
		p.Virt = p
	}

	return p.BaseLexer.NextToken()
}

func (p *PositionAdjustingLexer) Emit() antlr.Token {
	switch p.GetType() {
	case PositionAdjustingLexerTOKENS:
		p.HandleAcceptPositionForKeyword("tokens")

	case PositionAdjustingLexerLABEL:
		p.HandleAcceptPositionForIdentifier()
	}

	return p.BaseLexer.Emit()
}

func isIdentifierChar(c rune) bool {
	return unicode.IsLetter(c) || unicode.IsDigit(c) || c == '_'
}

func (p *PositionAdjustingLexer) HandleAcceptPositionForIdentifier() bool {
	var tokenText = p.GetText()
	var identifierLength int

	for identifierLength \< len(tokenText) && isIdentifierChar([]rune(tokenText)[identifierLength]) {
		identifierLength++
	}

	if p.GetInputStream().Index() \<= p.TokenStartCharIndex + identifierLength {
		return false
	}

	var offset = identifierLength - 1

	p.GetInterpreter().(*PositionAdjustingLexerATNSimulator).ResetAcceptPosition(p.GetInputStream(), p.TokenStartCharIndex + offset, p.TokenStartLine, p.TokenStartColumn + offset)

	return true
}

func (p *PositionAdjustingLexer) HandleAcceptPositionForKeyword(keyword string) bool {
	if p.GetInputStream().Index() \<= p.TokenStartCharIndex + len(keyword) {
		return false
	}

	var offset = len(keyword) - 1

	p.GetInterpreter().(*PositionAdjustingLexerATNSimulator).ResetAcceptPosition(p.GetInputStream(), p.TokenStartCharIndex + offset, p.TokenStartLine, p.TokenStartColumn + offset)

	return true
}

type PositionAdjustingLexerATNSimulator struct {
	*antlr.LexerATNSimulator
}

func NewPositionAdjustingLexerATNSimulator(recog antlr.Lexer, atn *antlr.ATN, decisionToDFA []*antlr.DFA, sharedContextCache *antlr.PredictionContextCache) *PositionAdjustingLexerATNSimulator {
	return &PositionAdjustingLexerATNSimulator{
		LexerATNSimulator: antlr.NewLexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache),
	}
}

func (p *PositionAdjustingLexerATNSimulator) ResetAcceptPosition(input antlr.CharStream, index, line, charPositionInLine int) {
	input.Seek(index)
	p.Line = line
	p.CharPositionInLine = charPositionInLine
	p.Consume(input)
}

>>

TreeNodeWithAltNumField(X) ::= <<
@parser::members {

type MyRuleNode struct {
	*antlr.BaseParserRuleContext

	altNum int
}

func NewMyRuleNode(parent antlr.ParserRuleContext, invokingStateNumber int) *MyRuleNode {
	return &MyRuleNode{
		BaseParserRuleContext : antlr.NewBaseParserRuleContext(parent, invokingStateNumber),
	}
}

func (m *MyRuleNode) GetAltNumber() int {
	return m.altNum
}

func (m *MyRuleNode) SetAltNumber(altNum int) {
	m.altNum = altNum
}

}
>>

BasicListener(notused) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	return &LeafListener{BaseTListener: &BaseTListener{}}
}

func (*LeafListener) VisitTerminal(node antlr.TerminalNode) {
	fmt.Println(node.GetSymbol().GetText())
}
>>

WalkListener(s) ::= <<
var walker = antlr.NewParseTreeWalker()

walker.Walk(NewLeafListener(), <s>)
>>

TokenGetterListener(notused) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	return &LeafListener{BaseTListener: &BaseTListener{}}
}

func (*LeafListener) ExitA(ctx *AContext) {
	if ctx.GetChildCount() == 2 {
		fmt.Printf("%s %s %s", ctx.INT(0).GetSymbol().GetText(), ctx.INT(1).GetSymbol().GetText(), antlr.PrintArrayJavaStyle(antlr.TerminalNodeToStringArray(ctx.AllINT())))
	} else {
		fmt.Println(ctx.ID().GetSymbol())
	}
}
>>

RuleGetterListener(notused) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	return &LeafListener{BaseTListener: &BaseTListener{}}
}

func (*LeafListener) ExitA(ctx *AContext) {
	if ctx.GetChildCount() == 2 {
		fmt.Printf("%s %s %s", ctx.B(0).GetStart().GetText(), ctx.B(1).GetStart().GetText(), ctx.AllB()[0].GetStart().GetText())
	} else {
		fmt.Println(ctx.B(0).GetStart().GetText())
	}
}
>>

LRListener(notused) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	return &LeafListener{BaseTListener: &BaseTListener{}}
}

func (*LeafListener) ExitE(ctx *EContext) {
	if ctx.GetChildCount() == 3 {
		fmt.Printf("%s %s %s\n", ctx.E(0).GetStart().GetText(), ctx.E(1).GetStart().GetText(), ctx.AllE()[0].GetStart().GetText())
	} else {
		fmt.Println(ctx.INT().GetSymbol().GetText())
	}
}
>>

LRWithLabelsListener(notused) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	return &LeafListener{BaseTListener: &BaseTListener{}}
}

func (*LeafListener) ExitCall(ctx *CallContext) {
	fmt.Printf("%s %s", ctx.E().GetStart().GetText(), ctx.EList().String(nil, nil))
}

func (*LeafListener) ExitInt(ctx *IntContext) {
	fmt.Println(ctx.INT().GetSymbol().GetText())
}
>>

ImportVisitor(X) ::= ""
BasicVisitor(X) ::= ""
WalkVisitor(s) ::= ""
LRWithLabelsVisitor(X) ::= ""
RuleGetterVisitor(X) ::= ""
LRVisitor(x) ::= ""
TokenGetterVisitor(x) ::= ""

DeclareContextListGettersFunction() ::= <<
func foo() {
	// TODO
	// var s SContext
	// var a = s.A()
	// var b = s.B()
}
>>

Declare_foo() ::= <<
func foo() {
	fmt.Println("foo")
}
>>

Invoke_foo() ::= "foo()"

Declare_pred() ::= <<
func pred(v bool) bool {
	fmt.Println("eval=" + fmt.Sprint(v))

	return v
}
>>

Invoke_pred(v) ::= <<pred(<v>)>>

ContextRuleFunction(ctx, rule) ::= "<ctx>.<rule>"
StringType() ::= "String"
ContextMember(ctx, subctx, member) ::= "<ctx>.<subctx>.<member>"

isEmpty ::= [
	"": true,
	default: false
]
