TestFile(file) ::= <<
/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.go;

import org.junit.Ignore;
import org.junit.Test;

import static org.junit.Assert.*;

<if(file.Options.("ImportGrammar"))>
import org.antlr.v4.tool.Grammar;
<endif>

public class Test<file.name> extends BaseTest {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}<\n>
>>

LexerTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(parserpkgdir);
<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
	writeFile(parserpkgdir, "<grammar>.g4", slave_<grammar>);
	}; separator="\n">

<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>
	<test.afterGrammar>
	String input =<writeStringLiteral(test.Input)>;
	String found = execLexer("<grammar>.g4", grammar, "<grammar><if(test.Options.("CombinedGrammar"))>Lexer<endif>", input, <writeBoolean(test.Options.("ShowDFA"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
    }>
}
>>


CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>

ParserTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(parserpkgdir);
<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
<if(test.Options.("SlaveIsLexer"))>
	rawGenerateAndBuildRecognizer("<grammar>.g4", slave_<grammar>, null, "<grammar>");
<else>
	writeFile(parserpkgdir, "<grammar>.g4", slave_<grammar>);
<endif>
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>
	<test.afterGrammar>
	String input =<writeStringLiteral(test.Input)>;
	String found = execParser("<grammar>.g4", grammar, "<grammar>Parser", "<grammar>Lexer",
	                          "<grammar>Listener", "<grammar>Visitor",
	                          "<test.Rule>", input, <writeBoolean(test.Options.("Debug"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
    }>
}
>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, <test.debug>);
}

>>

ConcreteParserTestMethod(test) ::= <<
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

testAnnotations(test) ::= <%
@Test
<if(test.Options.("Timeout"))>
(timeout = <test.Options.("Timeout")>)
<endif>
<if(test.Options.("Ignore"))>
<\n>@Ignore(<writeStringLiteral(test.Options.("Ignore"))>)
<elseif(IgnoredTests.(({<file.name>.<test.name>})))>
<\n>@Ignore(<writeStringLiteral(IgnoredTests.(({<file.name>.<test.name>})))>)
<endif>
%>

buildStringLiteral(text, variable) ::= <<
StringBuilder <variable>Builder = new StringBuilder(<strlen.(text)>);
<lines.(text):{line|<variable>Builder.append("<escape.(line)>");}; separator="\n">
String <variable> = <variable>Builder.toString();
>>

writeStringLiteral(text) ::= <%
<if(isEmpty.(text))>
""
<else>
<writeLines(lines.(text))>
<endif>
%>

writeLines(textLines) ::= <%
<if(rest(textLines))>
<textLines:{line|
<\n>		"<escape.(line)>}; separator="\" +">"
<else>
"<escape.(first(textLines))>"
<endif>
%>





string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= <<fmt.Println(<s>)>>

write(s) ::= <<fmt.Print(<s>)>>

False() ::= "false"

True() ::= "true"

Not(v) ::= "!<v>"

Assert(s) ::= ""

Cast(t,v) ::= "(<v>)"

Append(a,b) ::= "<a> + fmt.Sprint(<b>)"

Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "<s> := <v>"

AssertIsList(v) ::= ""

AssignLocal(s,v) ::= "<s> = <v>;"

InitIntMember(n,v) ::= <%var <n> int = <v>; var _ int = <n>; %>

InitBooleanMember(n,v) ::= <%var <n> bool= <v>; var _ bool = <n>; %>

GetMember(n) ::= <%<n>%>

SetMember(n,v) ::= <%<n> = <v>;%>

AddMember(n,v) ::= <%<n> += <v>;%>

PlusMember(v,n) ::= <%<v> + <n>%>

MemberEquals(n,v) ::= <%<n> == <v>%>

ModMemberEquals(n,m,v) ::= <%<n> % <m> == <v>%>

ModMemberNotEquals(n,m,v) ::= <%<n> % <m> != <v>%>

DumpDFA() ::= "p.DumpDFA()"

Pass() ::= ""

StringList() ::= "[]string"

BuildParseTrees() ::= "p.BuildParseTrees = true"

BailErrorStrategy() ::= <%SetErrorHandler(NewBailErrorStrategy())%>

ToStringTree(s) ::= <%<s>.ToStringTree(nil,p)%>

Column() ::= "p.GetCharPositionInLine()"

Text() ::= "l.GetText()"

ValEquals(a,b) ::= <%<a>==<b>%>

TextEquals(a) ::= <%p.GetText() == "<a>"%>

PlusText(a) ::= <%"<a>" + l.GetText()%>

InputText() ::= "p.GetTokenStream().GetAllText()"

LTEquals(i, v) ::= <%p.GetTokenStream().LT(<i>).GetText() == <v>%>

LANotEquals(i, v) ::= <%p.GetTokenStream().LA(<i>)!=<v>%>

TokenStartColumnEquals(i) ::= <%p.TokenStartColumn==<i>%>

ImportListener(X) ::= ""

GetExpectedTokenNames() ::= "p.GetExpectedTokens().StringVerbose(p.GetTokenNames(), nil, false)"

RuleInvocationStack() ::= "p.GetRuleInvocationStack(nil)"

LL_EXACT_AMBIG_DETECTION() ::= <<p.Interpreter.SetPredictionMode(antlr4.PredictionModeLLExactAmbigDetection);>>

ParserPropertyMember() ::= <<
@members {
func Property() bool {
  return true
}
}
>>

PositionAdjustingLexer() ::= <<
package antlrtest

type PositionAdjustingLexer struct {
	antlr4.*BaseLexer
}

func NewPositionAdjustingLexer(input antlr4.CharStream) *PositionAdjustingLexer {
	l := new(PositionAdjustingLexer)
	l.BaseLexer = antlr4.NewBaseLexer( input )
	return l
}

func (this *PositionAdjustingLexer) NextToken() *Token {

	_,ok := this._interp.(*PositionAdjustingLexerATNSimulator)

	if !ok {
		this._interp = NewPositionAdjustingLexerATNSimulator(this, _ATN, _decisionToDFA, _sharedContextCache)
	}

	return this.BaseLexer.NextToken()
}

func (this *PositionAdjustingLexer) Emit() *Token {
	switch (_type) {
	case TOKENS:
		this.HandleAcceptPositionForKeyword("tokens")

	case LABEL:
		this.HandleAcceptPositionForIdentifier()
	}

	return this.BaseLexer.Emit()
}

func (this *PositionAdjustingLexer) HandleAcceptPositionForIdentifier() bool {
 	tokenText := GetText()
	identifierLength int = 0
	for identifierLength \< len(tokenText) && isIdentifierChar(tokenText.charAt(identifierLength)) {
		identifierLength += 1
	}

	if GetInputStream().Index() > _tokenStartCharIndex + identifierLength {
		offset int = identifierLength - 1
		this.GetInterpreter().ResetAcceptPosition(this.GetInputStream(), this.TokenStartCharIndex + offset, this.TokenStartLine, this.TokenStartCharPositionInLine + offset)
		return true
	}

	return false
}

func (this *PositionAdjustingLexer) HandleAcceptPositionForKeyword(keyword string) bool {
	if this.GetInputStream().Index() > this.TokenStartCharIndex + len(keyword) {
		offset := len(keyword) - 1
		this.GetInterpreter().ResetAcceptPosition(this.GetInputStream(), this.TokenStartCharIndex + offset, this.TokenStartLine, this.TokenStartCharPositionInLine + offset)
		return true
	}

	return false
}

func (s *PositionAdjustingLexer) GetInterpreter() *LexerATNSimulator {
	return s // return super.(*PositionAdjustingLexerATNSimulator).GetInterpreter()
}

func isIdentifierChar(c rune) bool {
	return Character.isLetterOrDigit(c) || c == '_'
}

type PositionAdjustingLexerATNSimulator struct {
    *antlr4.LexerATNSimulator
}

func NewPositionAdjustingLexerATNSimulator(recog antlr4.Lexer, atn *antlr4.ATN, decisionToDFA []*antlr4.DFA, sharedContextCache *PredictionContextCache) *PositionAdjustingLexerATNSimulator {

    l := new(PositionAdjustingLexerATNSimulator)

	l.LexerATNSimulator = antlr4.NewLexerATNSimulator(recog, atn, decisionToDFA, sharedContextCache)

	return l
}

func (this *NewPositionAdjustingLexerATNSimulator) ResetAcceptPosition(input CharStream, index, line, charPositionInLine int) {
    this.GetInputStream().Seek(index);
    this.Line = line;
    this.CharPositionInLine = charPositionInLine;
    this.Consume(input);
}

>>

BasicListener(X) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	l := new(LeafListener)
	l.BaseTListener = new(BaseTListener)
	return l
}

func (this *LeafListener) VisitTerminal( node antlr4.TerminalNode ) {
	fmt.Println(node.GetSymbol().GetText())
}
>>

WalkListener(s) ::= <<
walker := antlr4.NewParseTreeWalker();
walker.Walk(NewLeafListener(), <s>);
>>

TokenGetterListener(X) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	l := new(LeafListener)
	l.BaseTListener = new(BaseTListener)
	return l
}

func (this *LeafListener) ExitA(ctx *AContext) {
	if (ctx.GetChildCount()==2){
		fmt.Printf("%s %s %s",ctx.INT(0)[0].GetSymbol().GetText(), ctx.INT(1)[0].GetSymbol().GetText(),ctx.INT(0)[0]);
	} else {
		fmt.Println(ctx.ID().GetSymbol())
	}
}
>>

RuleGetterListener(X) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	l := new(LeafListener)
	l.BaseTListener = new(BaseTListener)
	return l
}

func (this *LeafListener) ExitA(ctx *AContext) {
	if (ctx.GetChildCount()==2) {
		fmt.Printf("%s %s %s",ctx.B(0)[0].GetStart().GetText(),ctx.B(1)[0].GetStart().GetText(),ctx.B(-1)[0].GetStart().GetText());
	} else {
		fmt.Println(ctx.B(0)[0].GetStart().GetText());
	}
}
>>

LRListener(X) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	l := new(LeafListener)
	l.BaseTListener = new(BaseTListener)
	return l
}

func (this *LeafListener) ExitE(ctx *EContext) {
	if (ctx.GetChildCount()==3) {
		fmt.Printf("%s %s %s\n",ctx.E(0)[0].GetStart().GetText(), ctx.E(1)[0].GetStart().GetText(), ctx.E(-1)[0].GetStart().GetText());
	} else {
		fmt.Println(ctx.INT().GetSymbol().GetText())
	}
}
>>

LRWithLabelsListener(X) ::= <<
type LeafListener struct {
	*BaseTListener
}

func NewLeafListener() *LeafListener {
	l := new(LeafListener)
	l.BaseTListener = new(BaseTListener)
	return l
}

func (this *LeafListener) ExitCall(ctx *CallContext) {
	fmt.Printf("%s %s",ctx.E().GetStart().GetText(),ctx.EList());
}

func (this *LeafListener) ExitInt(ctx *IntContext) {
	fmt.Println(ctx.INT().GetSymbol().GetText());
}
>>

DeclareContextListGettersFunction() ::= <<
func foo() {
	SContext s = null;
	List\<? extends AContext> a = s.a();
	List\<? extends BContext> b = s.b();
}
>>

Declare_foo() ::= <<
func foo() {
	fmt.Println("foo")
}
>>

Invoke_foo() ::= "foo()"

Declare_pred() ::= <<
func pred(v bool) bool {
	fmt.Println("eval="+fmt.Sprint(v))
	return v
}
>>

Invoke_pred(v) ::= <<p.pred(<v>)>>

IgnoredTests ::= [
	default: false
]

isEmpty ::= [
	"": true,
	default: false
]
