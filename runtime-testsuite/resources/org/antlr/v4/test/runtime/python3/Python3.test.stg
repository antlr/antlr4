IgnoredTests ::= [
	"Visitors.Basic": true,
	"Visitors.LR": true,
	"Visitors.LRWithLabels": true,
	"Visitors.RuleGetters_1": true,
	"Visitors.RuleGetters_2": true,
	"Visitors.TokenGetters_1": true,
	"Visitors.TokenGetters_2": true,
	default: false
]

TestFile(file) ::= <<
/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.python3;

import org.junit.Ignore;
import org.junit.Test;
import static org.junit.Assert.*;

<if(file.Options.("ImportErrorQueue"))>
import org.antlr.v4.test.runtime.java.ErrorQueue;
<endif>
<if(file.Options.("ImportGrammar"))>
import org.antlr.v4.tool.Grammar;
<endif>

@SuppressWarnings("unused")
public class Test<file.name> extends BasePython3Test {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}
>>

LexerTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

<if(test.AfterGrammar)>
	<test.AfterGrammar>
<endif>
	String input =<writeStringLiteral(test.Input)>;
	String found = execLexer("<grammar>.g4", grammar, "<grammar><if(test.Options.("CombinedGrammar"))>Lexer<endif>", input, <writeBoolean(test.Options.("ShowDFA"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>

ParserTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
<if(test.Options.("SlaveIsLexer"))>
	rawGenerateAndBuildRecognizer("<grammar>.g4", slave_<grammar>, null, "<grammar>");
<else>
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
<endif>
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

	<test.AfterGrammar>

	String input =<writeStringLiteral(test.Input)>;
	String found = execParser("<grammar>.g4", grammar, "<grammar><if(!test.slaveIsLexer)>Parser<endif>", "<if(test.slaveIsLexer)><first(test.slaveGrammars).grammarName><else><grammar>Lexer<endif>", "<grammar>Listener", "<grammar>Visitor", "<test.Rule>", input, <writeBoolean(test.Options.("Debug"))>);

	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
/* this file and method are generated, any edit will be overwritten by the next generation */
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, <test.debug>);
}

>>

ConcreteParserTestMethod(test) ::= <<
/* this file and method are generated, any edit will be overwritten by the next generation */
@Test
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

testAnnotations(test) ::= <%
@Test
<if(test.Options.("Ignore"))>
<\n>@Ignore(<writeStringLiteral(test.Options.("Ignore"))>)
<elseif(IgnoredTests.(({<file.name>.<test.name>})))>
<\n>@Ignore(<writeStringLiteral(IgnoredTests.(({<file.name>.<test.name>})))>)
<endif>
%>

buildStringLiteral(text, variable) ::= <<
StringBuilder <variable>Builder = new StringBuilder(<strlen.(text)>);
<lines.(text):{line|<variable>Builder.append("<escape.(line)>");}; separator="\n">
String <variable> = <variable>Builder.toString();
>>

writeStringLiteral(text) ::= <%
<if(isEmpty.(text))>
""
<else>
<writeLines(lines.(text))>
<endif>
%>

writeLines(textLines) ::= <%
<if(rest(textLines))>
<textLines:{line|
<\n>		"<escape.(line)>}; separator="\" +">"
<else>
"<escape.(first(textLines))>"
<endif>
%>

string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= <<print(<s>)>>

write(s) ::= <<print(<s>,end='')>>

False() ::= "False"

True() ::= "True"

Not(v) ::= "not <v>"

Assert(s) ::= ""

Cast(t,v) ::= "<v>"

Append(a,b) ::= "<a> + str(<b>)"

Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "<s> = <v>"

AssertIsList(v) ::= "assert isinstance(v, (list, tuple))"

AssignLocal(s,v) ::= "<s> = <v>"

InitIntMember(n,v) ::= <%<n> = <v>%>

InitBooleanMember(n,v) ::= <%<n> = <v>%>

GetMember(n) ::= <%self.<n>%>

SetMember(n,v) ::= <%self.<n> = <v>%>

AddMember(n,v) ::= <%self.<n> += <v>%>

PlusMember(v,n) ::= <%<v> + str(self.<n>)%>

MemberEquals(n,v) ::= <%self.<n> == <v>%>

ModMemberEquals(n,m,v) ::= <%self.<n> % <m> == <v>%>

ModMemberNotEquals(n,m,v) ::= <%self.<n> % <m> != <v>%>

DumpDFA() ::= "self.dumpDFA()"

Pass() ::= "pass"

StringList() ::= ""

BuildParseTrees() ::= "self._buildParseTrees = True"

BailErrorStrategy() ::= <%self._errHandler = BailErrorStrategy()%>

ToStringTree(s) ::= <%<s>.toStringTree(recog=self)%>

Column() ::= "self.column"

Text() ::= "self.text"

ValEquals(a,b) ::= <%<a>==<b>%>

TextEquals(a) ::= <%self.text=="<a>"%>

PlusText(a) ::= <%"<a>" + self.text%>

InputText() ::= "self._input.getText()"

LTEquals(i, v) ::= <%self._input.LT(<i>).text==<v>%>

LANotEquals(i, v) ::= <%self._input.LA(<i>)!=<v>%>

TokenStartColumnEquals(i) ::= <%self._tokenStartColumn==<i>%>

ImportListener(X) ::= <<class MockListener:
    pass
>>

GetExpectedTokenNames() ::= "self.getExpectedTokens().toString(self.literalNames, self.symbolicNames)"

RuleInvocationStack() ::= "str_list(self.getRuleInvocationStack())"

LL_EXACT_AMBIG_DETECTION() ::= <<self._interp.predictionMode =  PredictionMode.LL_EXACT_AMBIG_DETECTION>>

ParserToken(parser, token) ::= <%<parser>.<token>%>

Production(p) ::= <%<p>%>

Result(r) ::= <%<r>%>

ParserPropertyMember() ::= <<
@members {
def Property(self):
    return True

}
>>

PositionAdjustingLexer() ::= <<

def resetAcceptPosition(self, index, line, column):
	self._input.seek(index)
	self.line = line
	self.column = column
	self._interp.consume(self._input)

def nextToken(self):
	if self._interp.__dict__.get("resetAcceptPosition", None) is None:
		self._interp.__dict__["resetAcceptPosition"] = self.resetAcceptPosition
	return super(type(self),self).nextToken()

def emit(self):
	if self._type==PositionAdjustingLexer.TOKENS:
		self.handleAcceptPositionForKeyword("tokens")
	elif self._type==PositionAdjustingLexer.LABEL:
		self.handleAcceptPositionForIdentifier()
	return super(type(self),self).emit()

def handleAcceptPositionForIdentifier(self):
	tokenText = self.text
	identifierLength = 0
	while identifierLength \< len(tokenText) and self.isIdentifierChar(tokenText[identifierLength]):
		identifierLength += 1

	if self._input.index > self._tokenStartCharIndex + identifierLength:
		offset = identifierLength - 1
		self._interp.resetAcceptPosition(self._tokenStartCharIndex + offset,
				self._tokenStartLine, self._tokenStartColumn + offset)
		return True
	else:
		return False


def handleAcceptPositionForKeyword(self, keyword):
	if self._input.index > self._tokenStartCharIndex + len(keyword):
		offset = len(keyword) - 1
		self._interp.resetAcceptPosition(self._tokenStartCharIndex + offset,
			self._tokenStartLine, self._tokenStartColumn + offset)
		return True
	else:
		return False

@staticmethod
def isIdentifierChar(c):
	return c.isalnum() or c == '_'

>>

BasicListener(X) ::= <<
class LeafListener(MockListener):
    def visitTerminal(self, node):
        print(node.symbol.text)

>>

WalkListener(s) ::= <<
if __name__ is not None and "." in __name__:
    from .TListener import TListener
else:
    from TListener import TListener
TParser.LeafListener.__bases__ = (TListener,)
walker = ParseTreeWalker()
walker.walk(TParser.LeafListener(), <s>)
>>

TreeNodeWithAltNumField(X) ::= <<
@parser::members {
class MyRuleNode(ParserRuleContext):
    def __init__(self, parent:ParserRuleContext = None, invokingStateNumber:int = None ):
        super(<X>Parser.MyRuleNode, self).__init__(parent, invokingStateNumber)
        self.altNum = 0;
    def getAltNumber(self):
        return self.altNum
    def setAltNumber(self, altNum):
        self.altNum = altNum
}
>>

TokenGetterListener(X) ::= <<
class LeafListener(MockListener):
    def exitA(self, ctx):
        if ctx.getChildCount()==2:
            print(ctx.INT(0).symbol.text + ' ' + ctx.INT(1).symbol.text + ' ' + str_list(ctx.INT()))
        else:
            print(str(ctx.ID().symbol))

>>

RuleGetterListener(X) ::= <<
class LeafListener(MockListener):
    def exitA(self, ctx):
        if ctx.getChildCount()==2:
            print(ctx.b(0).start.text + ' ' + ctx.b(1).start.text + ' ' + ctx.b()[0].start.text)
        else:
            print(ctx.b(0).start.text)

>>


LRListener(X) ::= <<
class LeafListener(MockListener):
    def exitE(self, ctx):
        if ctx.getChildCount()==3:
            print(ctx.e(0).start.text + ' ' + ctx.e(1).start.text + ' ' + ctx.e()[0].start.text)
        else:
            print(ctx.INT().symbol.text)

>>

LRWithLabelsListener(X) ::= <<
class LeafListener(MockListener):
    def exitCall(self, ctx):
        print(ctx.e().start.text + ' ' + str(ctx.eList()))
    def exitInt(self, ctx):
        print(ctx.INT().symbol.text)

>>

DeclareContextListGettersFunction() ::= <<
def foo():
    s = SContext()
    a = s.a()
    b = s.b()
>>

Declare_foo() ::= <<def foo(self):
	print('foo')
>>

Invoke_foo() ::= "self.foo()"

Declare_pred() ::= <<def pred(self, v):
	print('eval=' + str(v).lower())
	return v

>>

Invoke_pred(v) ::= <<self.pred(<v>)>>

isEmpty ::= [
	"": true,
	default: false
]
