IgnoredTests ::= [
	default: false
]

Generating target Swift
TestFile(file) ::= <<
/* This file is generated by TestGenerator, any edits will be overwritten by the next generation. */
package org.antlr.v4.test.runtime.swift;

import org.junit.Test;
import org.junit.Ignore;

<if(file.Options.("ImportErrorQueue"))>
import org.antlr.v4.test.runtime.java.ErrorQueue;
<endif>
<if(file.Options.("ImportGrammar"))>
import org.antlr.v4.tool.Grammar;
<endif>

@SuppressWarnings("unused")
public class Test<file.name> extends BaseTest {

	<file.tests:{test | <test>}; separator="\n", wrap, anchor>

}<\n>
>>

LexerTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

<if(test.AfterGrammar)>
	<test.AfterGrammar>
<endif>
	String input =<writeStringLiteral(test.Input)>;
	String found = execLexer("<grammar>.g4", grammar, "<grammar><if(test.Options.("CombinedGrammar"))>Lexer<endif>", input, <writeBoolean(test.Options.("ShowDFA"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeLexerTestMethod(test) ::= <<
<LexerTestMethod(test)>
>>

ParserTestMethod(test) ::= <<
/* This file and method are generated by TestGenerator, any edits will be overwritten by the next generation. */
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	mkdir(tmpdir);

<test.SlaveGrammars:{grammar |
	String slave_<grammar> =<writeStringLiteral(test.SlaveGrammars.(grammar))>;
<if(test.Options.("SlaveIsLexer"))>
	rawGenerateAndBuildRecognizer("<grammar>.g4", slave_<grammar>, null, "<grammar>");
<else>
	writeFile(tmpdir, "<grammar>.g4", slave_<grammar>);
<endif>
	}; separator="\n">
<test.Grammar:{grammar |
	<buildStringLiteral(test.Grammar.(grammar), "grammar")>

	<test.AfterGrammar>

	String input =<writeStringLiteral(test.Input)>;
	String found = execParser("<grammar>.g4", grammar, "<grammar>Parser", "<grammar>Lexer", "<test.Rule>", input, <writeBoolean(test.Options.("Debug"))>);
	assertEquals(<writeStringLiteral(test.Output)>, found);
	<if(!isEmpty.(test.Errors))>
	assertEquals(<writeStringLiteral(test.Errors)>, this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
	}>
}

>>

CompositeParserTestMethod(test) ::= <<
<ParserTestMethod(test)>
>>

AbstractParserTestMethod(test) ::= <<
String test<test.name>(String input) throws Exception {
	String grammar = <test.grammar.lines:{ line | "<line>};separator="\\n\" +\n", wrap, anchor>";
	return execParser("<test.grammar.grammarName>.g4", grammar, "<test.grammar.grammarName>Parser", "<test.grammar.grammarName>Lexer", "<test.startRule>", input, <test.debug>);
}

>>

ConcreteParserTestMethod(test) ::= <<
<testAnnotations(test)>
public void test<test.name>() throws Exception {
	String found = test<test.baseName>("<test.input>");
	assertEquals("<test.expectedOutput>", found);
	<if(test.expectedErrors)>
	assertEquals("<test.expectedErrors>", this.stderrDuringParse);
	<else>
	assertNull(this.stderrDuringParse);
	<endif>
}

>>

testAnnotations(test) ::= <%
@Test
<if(test.Options.("Timeout"))>
(timeout = <test.Options.("Timeout")>)
<endif>
<if(test.Options.("Ignore"))>
<\n>@Ignore(<writeStringLiteral(test.Options.("Ignore"))>)
<elseif(IgnoredTests.(({<file.name>.<test.name>})))>
<\n>@Ignore(<writeStringLiteral(IgnoredTests.(({<file.name>.<test.name>})))>)
<endif>
%>

buildStringLiteral(text, variable) ::= <<
StringBuilder <variable>Builder = new StringBuilder(<strlen.(text)>);
<lines.(text):{line|<variable>Builder.append("<escape.(line)>");}; separator="\n">
String <variable> = <variable>Builder.toString();
>>

writeStringLiteral(text) ::= <%
<if(isEmpty.(text))>
""
<else>
<writeLines(lines.(text))>
<endif>
%>

writeLines(textLines) ::= <%
<if(rest(textLines))>
<textLines:{line|
<\n>		"<escape.(line)>}; separator="\" +">"
<else>
"<escape.(first(textLines))>"
<endif>
%>

string(text) ::= <<
"<escape.(text)>"
>>

writeBoolean(o) ::= "<if(o && !isEmpty.(o))>true<else>false<endif>"

writeln(s) ::= <<print(<s>)>>

write(s) ::= <<print(<s; format="replaceSingleQuotation">, terminator: "")>>

False() ::= "false"

True() ::= "true"

Not(v) ::= "!<v>"

Assert(s) ::= ""

Cast(t,v) ::= "((<v> as! <t>))"

Append(a,b) ::= "<a> + <b>"

Concat(a,b) ::= "<a><b>"

DeclareLocal(s,v) ::= "var <s> = <v>"

AssertIsList(v) ::= "var __ttt__ = <v>;" // just use static type system

AssignLocal(s,v) ::= "<s> = <v>"

InitIntMember(n,v) ::= <%var <n> = <v>%>

InitBooleanMember(n,v) ::= <%var <n> = <v>%>

GetMember(n) ::= <%self.<n>%>

SetMember(n,v) ::= <%self.<n> = <v>%>

AddMember(n,v) ::= <%self.<n> += <v>%>

PlusMember(v,n) ::= <%<v> + self.<n>%>

MemberEquals(n,v) ::= <%self.<n> == <v>%>

ModMemberEquals(n,m,v) ::= <%self.<n> % <m> == <v>%>

ModMemberNotEquals(n,m,v) ::= <%self.<n> % <m> != <v>%>

DumpDFA() ::= "self.dumpDFA()"

Pass() ::= ""

StringList() ::= "Array\<String>"

BuildParseTrees() ::= "setBuildParseTree(true)"

BailErrorStrategy() ::= <%setErrorHandler(BailErrorStrategy())%>

ToStringTree(s) ::= <%<s>.toStringTree(self)%>

Column() ::= "self.getCharPositionInLine()"

Text() ::= "self.getText()"

ValEquals(a,b) ::= <%<a>==<b>%>

TextEquals(a) ::= <%self.getText() == "<a>"%>

PlusText(a) ::= <%"<a>" + self.getText()%>

InputText() ::= "try self._input.getText()"

LTEquals(i, v) ::= <%try self._input.LT(<i>)?.getText() == <v>%>

LANotEquals(i, v) ::= <%try self._input.LA(<i>) != <v>%>

TokenStartColumnEquals(i) ::= <%self._tokenStartCharPositionInLine == <i>%>

ImportListener(X) ::= ""

OptionalValue(value) ::= "<value>!"


GetExpectedTokenNames() ::= "try self.getExpectedTokens().toString(self.tokenNames)"

RuleInvocationStack() ::= "getRuleInvocationStack().description.replacingOccurrences(of: \"\\\"\", with: \"\")"

LL_EXACT_AMBIG_DETECTION() ::= <<_interp.setPredictionMode(PredictionMode.LL_EXACT_AMBIG_DETECTION);>>

ParserPropertyMember() ::= <<
@members {
func Property() -> Bool {
  return true
}
}
>>

PositionAdjustingLexer() ::= <<

override
open func nextToken() throws -> Token {
	if (!(_interp is PositionAdjustingLexerATNSimulator)) {
		_interp = PositionAdjustingLexerATNSimulator(self, PositionAdjustingLexer._ATN, PositionAdjustingLexer._decisionToDFA, PositionAdjustingLexer._sharedContextCache)
	}

	return try super.nextToken()
}

override
open func emit() -> Token  {
	switch (_type) {
	case PositionAdjustingLexer.TOKENS:
		handleAcceptPositionForKeyword("tokens")
	case PositionAdjustingLexer.LABEL:
		handleAcceptPositionForIdentifier()
	default:
		break
	}
	return super.emit()
}

private func handleAcceptPositionForIdentifier() -> Bool {
	let tokenText = getText()
	var identifierLength = 0
	while ((identifierLength \< tokenText.length)  &&  isIdentifierChar(tokenText[tokenText.characters.index(tokenText.startIndex, offsetBy: identifierLength)])) {
		identifierLength += 1
	}

	if (getInputStream()!.index() > _tokenStartCharIndex + identifierLength) {
		let offset = identifierLength - 1
		(getInterpreter() as! PositionAdjustingLexerATNSimulator).resetAcceptPosition(getInputStream()!, _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset)
		return true
	}

	return false
}

private func handleAcceptPositionForKeyword(_ keyword:String) -> Bool  {
	if  getInputStream()!.index() > _tokenStartCharIndex + keyword.length   {
		let offset = keyword.length  - 1
		(getInterpreter() as! PositionAdjustingLexerATNSimulator).resetAcceptPosition(getInputStream()!, _tokenStartCharIndex + offset, _tokenStartLine, _tokenStartCharPositionInLine + offset)
		return true
	}

	return false
}


//public func getInterpreter() -> PositionAdjustingLexerATNSimulator {
//	return super.getInterpreter() as! PositionAdjustingLexerATNSimulator
//}

private  func isIdentifierChar(_ c: Character) -> Bool  {
	return (c >= "0" && c \<= "9") || (c >= "a" && c \<= "z") || c >= "A" && c \<= "Z" || c == "_"
}

class PositionAdjustingLexerATNSimulator: LexerATNSimulator {

	  init(_ recog: Lexer,_ atn: ATN,
				 _ decisionToDFA: [DFA],
				 _ sharedContextCache:PredictionContextCache)
	{
		super.init(recog, atn, decisionToDFA, sharedContextCache)
	}

   func resetAcceptPosition(_ input: CharStream,_ index: Int,_ line: Int,_ charPositionInLine: Int) {
		try! input.seek(index)
		self.line = line
		self.charPositionInLine = charPositionInLine
		try! consume(input)
	}

}

>>

BasicListener(X) ::= <<
open class LeafListener: TBaseListener {
    override
	open func visitTerminal(_ node: TerminalNode) {
		print(node.getSymbol()?.getText() ?? "")
	}
}
>>

WalkListener(s) ::= <<
let walker =  ParseTreeWalker()
try! walker.walk(LeafListener(), <s>)
>>

TokenGetterListener(X) ::= <<
open class LeafListener: TBaseListener {
    override
	open func exitA(_ ctx: TParser.AContext) {
		if (ctx.getChildCount() == 2) {
			print("\(ctx.INT(0)?.getSymbol()?.getText() ?? "") \(ctx.INT(1)?.getSymbol()?.getText() ?? "") \(ctx.INT())")
		}
		else {
			print(ctx.ID()?.getSymbol() ?? "")
		}
	}
}

>>

RuleGetterListener(X) ::= <<
open class LeafListener: TBaseListener {
    override
	open func exitA(_ ctx: TParser.AContext) {
		if (ctx.getChildCount() == 2) {
			print("\(ctx.b(0)?.start?.getText() ?? "") \(ctx.b(1)?.start?.getText() ?? "") \(ctx.b()[0].start?.getText() ?? "")")
		} else {
			print(ctx.b(0)?.start?.getText() ?? "")
		}
	}
}
>>


LRListener(X) ::= <<
open class LeafListener: TBaseListener {
    override
	open func exitE(_ ctx: TParser.EContext) {
		if (ctx.getChildCount() == 3) {
		    print("\(ctx.e(0)?.start?.getText() ?? "") \(ctx.e(1)?.start?.getText() ?? "") \(ctx.e()[0].start?.getText() ?? "")")
		} else {
			print(ctx.INT()?.getSymbol()?.getText() ?? "")
	   }
	}
}


>>

LRWithLabelsListener(X) ::= <<
open class LeafListener: TBaseListener {
    override
	open func exitCall(_ ctx: TParser.CallContext) {
		print("\(ctx.e()?.start?.getText() ?? "") \(ctx.eList()!)")
	}
	override
	open func exitInt(_ ctx: TParser.IntContext) {
		print(ctx.INT()?.getSymbol()?.getText() ?? "")
	}
}
>>

DeclareContextListGettersFunction() ::= <<
func foo() {
	//let s: SContext? = nil
	//let a: [AContext]? = s?.a()
	//let b: [BContext]? = s?.b()
}
>>

Declare_foo() ::= <<
	public func foo() {print("foo")}
>>

Invoke_foo() ::= "foo()"

Declare_pred() ::= <<
func pred(_ v: Bool) -> Bool {
	print("eval=\(v)")
	return v
}
>>

Invoke_pred(v) ::= <<self.pred(<v>)>>


isEmpty ::= [
	"": true,
	default: false
]
