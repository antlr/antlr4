[type]
Runtime

[codeDeclaration]
[Java]
static void emptyListToEmptyCharArray() {
	IntegerList l = new IntegerList();
	assertArrayEquals(new char[0], l.toCharArray());
}

static void negativeIntegerToCharArrayThrows() {
	IntegerList l = new IntegerList();
	l.add(-42);
	try {
		l.toCharArray();
	} catch (IllegalArgumentException e) {
		return;
	}
	assert false;
}

static void surrogateRangeIntegerToCharArray() {
	IntegerList l = new IntegerList();
	// Java allows dangling surrogates, so (currently) we do
	// as well. We could change this if desired.
	l.add(0xDC00);
	char[] expected = new char[] { 0xDC00 };
	assertArrayEquals(expected, l.toCharArray());
}

static void tooLargeIntegerToCharArrayThrows() {
	IntegerList l = new IntegerList();
	l.add(0x110000);
	try {
		l.toCharArray();
	} catch (IllegalArgumentException e) {
		return;
	}
	assert false;
}

static void unicodeBMPIntegerListToCharArray() {
	IntegerList l = new IntegerList();
	l.add(0x35);
	l.add(0x4E94);
	l.add(0xFF15);
	char[] expected = new char[] { 0x35, 0x4E94, 0xFF15 };
	assertArrayEquals(expected, l.toCharArray());
}

static void unicodeSMPIntegerListToCharArray() {
	IntegerList l = new IntegerList();
	l.add(0x104A5);
	l.add(0x116C5);
	l.add(0x1D7FB);
	char[] expected = new char[] { 0xD801, 0xDCA5, 0xD805, 0xDEC5, 0xD835, 0xDFFB };
	assertArrayEquals(expected, l.toCharArray());
}

static void assertArrayEquals(char[] expected, char[] actual) {
	assert expected != null;
	assert actual != null;
	assert expected.length == actual.length;
	for (int i = 0; i < expected.length; i++) {
		assert expected[i] == actual[i];
	}
}

[codeCall]
[Java]
emptyListToEmptyCharArray();
negativeIntegerToCharArrayThrows();
surrogateRangeIntegerToCharArray();
tooLargeIntegerToCharArrayThrows();
unicodeBMPIntegerListToCharArray();
unicodeSMPIntegerListToCharArray();