import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;
import org.antlr.v4.runtime.atn.*;
import java.nio.file.Paths;
import java.util.Arrays;

public class Test {
	public static void main(String[] args) throws Exception {
<if(lexerName)>
		CharStream input = CharStreams.fromPath(Paths.get(args[0]));
		<lexerName> lexer = new <lexerName>(input);
		CommonTokenStream tokens = new CommonTokenStream(lexer);
<else>
		CommonTokenStream tokens = null; // It's required for compilation
<endif>
<if(parserName)>
		<parserName> parser = new <parserName>(tokens);
<if(debug)>
		parser.addErrorListener(new DiagnosticErrorListener());
<endif>
		parser.setBuildParseTree(true);
<if(profile)>
		ProfilingATNSimulator profiler = new ProfilingATNSimulator(parser);
		parser.setInterpreter(profiler);
<endif>
		ParserRuleContext tree = parser.<parserStartRuleName>();
<if(profile)>
		System.out.println(Arrays.toString(profiler.getDecisionInfo()));
<endif>
		ParseTreeWalker.DEFAULT.walk(new TreeShapeListener(), tree);
<else>
		tokens.fill();
		for (Object t : tokens.getTokens()) System.out.println(t);
<if(showDFA)>
		System.out.print(lexer.getInterpreter().getDFA(Lexer.DEFAULT_MODE).toLexerString());
<endif>
<endif>
	}

<if(parserName)>
	static class TreeShapeListener implements ParseTreeListener {
		@Override public void visitTerminal(TerminalNode node) { }
		@Override public void visitErrorNode(ErrorNode node) { }
		@Override public void exitEveryRule(ParserRuleContext ctx) { }

		@Override
		public void enterEveryRule(ParserRuleContext ctx) {
			for (int i = 0; i \< ctx.getChildCount(); i++) {
				ParseTree parent = ctx.getChild(i).getParent();
				if (!(parent instanceof RuleNode) || ((RuleNode)parent).getRuleContext() != ctx) {
					throw new IllegalStateException("Invalid parse tree shape detected.");
				}
			}
		}
	}
<endif>
}
