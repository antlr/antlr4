/* Copyright (c) 2012-2016 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */


/**
* This class provides a default implementation of the {@link org.antlr.v4.runtime.Vocabulary}
* interface.
*
* @author Sam Harwell
*/

public class Vocabulary: Hashable {
    private static let EMPTY_NAMES: [String?] = [String?](repeating: "", count: 1)

    /**
    * Gets an empty {@link org.antlr.v4.runtime.Vocabulary} instance.
    *
    * <p>
    * No literal or symbol names are assigned to token types, so
    * {@link #getDisplayName(int)} returns the numeric value for all tokens
    * except {@link org.antlr.v4.runtime.Token#EOF}.</p>
    */
    public static let EMPTY_VOCABULARY: Vocabulary = Vocabulary(EMPTY_NAMES, EMPTY_NAMES, EMPTY_NAMES)


    private final var literalNames: [String?]

    private final var symbolicNames: [String?]

    private final var displayNames: [String?]

    /**
    * Constructs a new instance of {@link org.antlr.v4.runtime.Vocabulary} from the specified
    * literal and symbolic token names.
    *
    * @param literalNames The literal names assigned to tokens, or {@code null}
    * if no literal names are assigned.
    * @param symbolicNames The symbolic names assigned to tokens, or
    * {@code null} if no symbolic names are assigned.
    *
    * @see #getLiteralName(int)
    * @see #getSymbolicName(int)
    */
    public convenience init(_ literalNames: [String?], _ symbolicNames: [String?]) {
        self.init(literalNames, symbolicNames, nil)
    }

    /**
    * Constructs a new instance of {@link org.antlr.v4.runtime.Vocabulary} from the specified
    * literal, symbolic, and display token names.
    *
    * @param literalNames The literal names assigned to tokens, or {@code null}
    * if no literal names are assigned.
    * @param symbolicNames The symbolic names assigned to tokens, or
    * {@code null} if no symbolic names are assigned.
    * @param displayNames The display names assigned to tokens, or {@code null}
    * to use the values in {@code literalNames} and {@code symbolicNames} as
    * the source of display names, as described in
    * {@link #getDisplayName(int)}.
    *
    * @see #getLiteralName(int)
    * @see #getSymbolicName(int)
    * @see #getDisplayName(int)
    */
    public init(_ literalNames: [String?]?, _ symbolicNames: [String?]?, _ displayNames: [String?]?) {
        self.literalNames = literalNames != nil ? literalNames! : Vocabulary.EMPTY_NAMES
        self.symbolicNames = symbolicNames != nil ? symbolicNames! : Vocabulary.EMPTY_NAMES
        self.displayNames = displayNames != nil ? displayNames! : Vocabulary.EMPTY_NAMES
    }

    /**
    * Returns a {@link org.antlr.v4.runtime.Vocabulary} instance from the specified set of token
    * names. This method acts as a compatibility layer for the single
    * {@code tokenNames} array generated by previous releases of ANTLR.
    *
    * <p>The resulting vocabulary instance returns {@code null} for
    * {@link #getLiteralName(int)} and {@link #getSymbolicName(int)}, and the
    * value from {@code tokenNames} for the display names.</p>
    *
    * @param tokenNames The token names, or {@code null} if no token names are
    * available.
    * @return A {@link org.antlr.v4.runtime.Vocabulary} instance which uses {@code tokenNames} for
    * the display names of tokens.
    */
    public static func fromTokenNames(_ tokenNames: [String?]?) -> Vocabulary {
        guard let tokenNames = tokenNames , tokenNames.count > 0  else {
            return EMPTY_VOCABULARY
        }

        var literalNames: [String?] = tokenNames// Arrays.copyOf(tokenNames, tokenNames.length);
        var symbolicNames: [String?] = tokenNames
        let length = tokenNames.count
        for i in 0..<length {
            guard let tokenName = tokenNames[i] else {
                continue
            }
            if !tokenName.isEmpty {
                let firstChar: Character = tokenName[0]
                if firstChar == "\'" {
                    symbolicNames[i] = nil
                    continue
                } else {
                    if String(firstChar).uppercased() != String(firstChar) {
                        literalNames[i] = nil
                        continue
                    }
                }
            }

            // wasn't a literal or symbolic name
            literalNames[i] = nil
            symbolicNames[i] = nil
        }

        return Vocabulary(literalNames, symbolicNames, tokenNames)
    }


    public func getLiteralName(_ tokenType: Int) -> String? {
        if tokenType >= 0 && tokenType < literalNames.count {
            return literalNames[tokenType]
        }

        return nil
    }


    public func getSymbolicName(_ tokenType: Int) -> String? {
        if tokenType >= 0 && tokenType < symbolicNames.count {
            return symbolicNames[tokenType]
        }
        if tokenType == CommonToken.EOF {
            return "EOF"
        }

        return nil
    }


    public func getDisplayName(_ tokenType: Int) -> String {
        if tokenType >= 0 && tokenType < displayNames.count {
            let displayName: String? = displayNames[tokenType]
            if displayName != nil {
                return displayName!
            }
        }

        let literalName: String? = getLiteralName(tokenType)
        if literalName != nil {
            return literalName!
        }

        let symbolicName: String? = getSymbolicName(tokenType)
        if symbolicName != nil {
            return symbolicName!
        }

        return String(tokenType)
    }

    public var hashValue: Int {
        return Unmanaged.passUnretained(self).toOpaque().hashValue
//        return unsafeAddress(of: self).hashValue
    }

}

public func ==(lhs: Vocabulary, rhs: Vocabulary) -> Bool {
    return lhs === rhs
}
