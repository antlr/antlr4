/*
* [The "BSD license"]
*  Copyright (c) 2014 Terence Parr
*  Copyright (c) 2014 Sam Harwell
*  Copyright (c) 2015 Janyou
*  All rights reserved.
*
*  Redistribution and use in source and binary forms, with or without
*  modification, are permitted provided that the following conditions
*  are met:
*
*  1. Redistributions of source code must retain the above copyright
*     notice, this list of conditions and the following disclaimer.
*  2. Redistributions in binary form must reproduce the above copyright
*     notice, this list of conditions and the following disclaimer in the
*     documentation and/or other materials provided with the distribution.
*  3. The name of the author may not be used to endorse or promote products
*     derived from this software without specific prior written permission.
*
*  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
*  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
*  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
*  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
*  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
*  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


/**
* This class provides a default implementation of the {@link org.antlr.v4.runtime.Vocabulary}
* interface.
*
* @author Sam Harwell
*/

public class Vocabulary: Hashable {
    private static let EMPTY_NAMES: [String?] = [String?](repeating: "", count: 1)

    /**
    * Gets an empty {@link org.antlr.v4.runtime.Vocabulary} instance.
    *
    * <p>
    * No literal or symbol names are assigned to token types, so
    * {@link #getDisplayName(int)} returns the numeric value for all tokens
    * except {@link org.antlr.v4.runtime.Token#EOF}.</p>
    */
    public static let EMPTY_VOCABULARY: Vocabulary = Vocabulary(EMPTY_NAMES, EMPTY_NAMES, EMPTY_NAMES)


    private final var literalNames: [String?]

    private final var symbolicNames: [String?]

    private final var displayNames: [String?]

    /**
    * Constructs a new instance of {@link org.antlr.v4.runtime.Vocabulary} from the specified
    * literal and symbolic token names.
    *
    * @param literalNames The literal names assigned to tokens, or {@code null}
    * if no literal names are assigned.
    * @param symbolicNames The symbolic names assigned to tokens, or
    * {@code null} if no symbolic names are assigned.
    *
    * @see #getLiteralName(int)
    * @see #getSymbolicName(int)
    */
    public convenience init(_ literalNames: [String?], _ symbolicNames: [String?]) {
        self.init(literalNames, symbolicNames, nil)
    }

    /**
    * Constructs a new instance of {@link org.antlr.v4.runtime.Vocabulary} from the specified
    * literal, symbolic, and display token names.
    *
    * @param literalNames The literal names assigned to tokens, or {@code null}
    * if no literal names are assigned.
    * @param symbolicNames The symbolic names assigned to tokens, or
    * {@code null} if no symbolic names are assigned.
    * @param displayNames The display names assigned to tokens, or {@code null}
    * to use the values in {@code literalNames} and {@code symbolicNames} as
    * the source of display names, as described in
    * {@link #getDisplayName(int)}.
    *
    * @see #getLiteralName(int)
    * @see #getSymbolicName(int)
    * @see #getDisplayName(int)
    */
    public init(_ literalNames: [String?]?, _ symbolicNames: [String?]?, _ displayNames: [String?]?) {
        self.literalNames = literalNames != nil ? literalNames! : Vocabulary.EMPTY_NAMES
        self.symbolicNames = symbolicNames != nil ? symbolicNames! : Vocabulary.EMPTY_NAMES
        self.displayNames = displayNames != nil ? displayNames! : Vocabulary.EMPTY_NAMES
    }

    /**
    * Returns a {@link org.antlr.v4.runtime.Vocabulary} instance from the specified set of token
    * names. This method acts as a compatibility layer for the single
    * {@code tokenNames} array generated by previous releases of ANTLR.
    *
    * <p>The resulting vocabulary instance returns {@code null} for
    * {@link #getLiteralName(int)} and {@link #getSymbolicName(int)}, and the
    * value from {@code tokenNames} for the display names.</p>
    *
    * @param tokenNames The token names, or {@code null} if no token names are
    * available.
    * @return A {@link org.antlr.v4.runtime.Vocabulary} instance which uses {@code tokenNames} for
    * the display names of tokens.
    */
    public static func fromTokenNames(_ tokenNames: [String?]?) -> Vocabulary {
        guard let tokenNames = tokenNames , tokenNames.count > 0  else {
            return EMPTY_VOCABULARY
        }

        var literalNames: [String?] = tokenNames// Arrays.copyOf(tokenNames, tokenNames.length);
        var symbolicNames: [String?] = tokenNames
        let length = tokenNames.count
        for i in 0..<length {
            guard let tokenName = tokenNames[i] else {
                continue
            }
            if !tokenName.isEmpty {
                let firstChar: Character = tokenName[0]
                if firstChar == "\'" {
                    symbolicNames[i] = nil
                    continue
                } else {
                    if String(firstChar).uppercased() != String(firstChar) {
                        literalNames[i] = nil
                        continue
                    }
                }
            }

            // wasn't a literal or symbolic name
            literalNames[i] = nil
            symbolicNames[i] = nil
        }

        return Vocabulary(literalNames, symbolicNames, tokenNames)
    }


    public func getLiteralName(_ tokenType: Int) -> String? {
        if tokenType >= 0 && tokenType < literalNames.count {
            return literalNames[tokenType]
        }

        return nil
    }


    public func getSymbolicName(_ tokenType: Int) -> String? {
        if tokenType >= 0 && tokenType < symbolicNames.count {
            return symbolicNames[tokenType]
        }
        if tokenType == CommonToken.EOF {
            return "EOF"
        }

        return nil
    }


    public func getDisplayName(_ tokenType: Int) -> String {
        if tokenType >= 0 && tokenType < displayNames.count {
            let displayName: String? = displayNames[tokenType]
            if displayName != nil {
                return displayName!
            }
        }

        let literalName: String? = getLiteralName(tokenType)
        if literalName != nil {
            return literalName!
        }

        let symbolicName: String? = getSymbolicName(tokenType)
        if symbolicName != nil {
            return symbolicName!
        }

        return String(tokenType)
    }

    public var hashValue: Int {
        return Unmanaged.passUnretained(self).toOpaque().hashValue
//        return unsafeAddress(of: self).hashValue
    }

}

public func ==(lhs: Vocabulary, rhs: Vocabulary) -> Bool {
    return lhs === rhs
}
