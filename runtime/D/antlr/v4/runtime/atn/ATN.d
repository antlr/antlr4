/*
 * Copyright (c) 2012-2018 The ANTLR Project. All rights reserved.
 * Use of this file is governed by the BSD 3-clause license that
 * can be found in the LICENSE.txt file in the project root.
 */

module antlr.v4.runtime.atn.ATN;

import std.conv;
import antlr.v4.runtime.IllegalArgumentException;
import antlr.v4.runtime.RuleContext;
import antlr.v4.runtime.atn.ATNState;
import antlr.v4.runtime.atn.ATNType;
import antlr.v4.runtime.atn.DecisionState;
import antlr.v4.runtime.atn.RuleStartState;
import antlr.v4.runtime.atn.RuleStopState;
import antlr.v4.runtime.atn.LL1Analyzer;
import antlr.v4.runtime.atn.RuleTransition;
import antlr.v4.runtime.Token;
import antlr.v4.runtime.TokenConstantDefinition;
import antlr.v4.runtime.atn.TokensStartState;
import antlr.v4.runtime.atn.LexerAction;
import antlr.v4.runtime.misc.IntervalSet;

/**
 * Class implementation adapted from Java code
 */
class ATN
{

    public static immutable int INVALID_ALT_NUMBER = 0;

    public ATNState[] states;

    /**
     * Each subrule/rule is a decision point and we must track them so we
     * can go back later and build DFA predictors for them.  This includes
     * all the rules, subrules, optional blocks, ()+, ()* etc...
     */
    public DecisionState[] decisionToState;

    /**
     * Maps from rule index to starting state number.
     */
    public RuleStartState[] ruleToStartState;

    /**
     * Maps from rule index to stop state number.
     */
    public RuleStopState[] ruleToStopState;

    public TokensStartState[string] modeNameToStartState;

    /**
     * The type of the ATN.
     */
    public ATNType grammarType;

    /**
     * The maximum value for any symbol recognized by a transition in the ATN.
     */
    public int maxTokenType;

    /**
     * For lexer ATNs, this maps the rule index to the resulting token type.
     * For parser ATNs, this maps the rule index to the generated bypass token
     * type if the
     * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
     * deserialization option was specified; otherwise, this is {@code null}.
     */
    public int[] ruleToTokenType;

    /**
     * For lexer ATNs, this is an array of {@link LexerAction} objects which may
     * be referenced by action transitions in the ATN.
     */
    public LexerAction[] lexerActions;

    public TokensStartState[] modeToStartState;

    /**
     * Used for runtime deserialization of ATNs from strings
     */
    public this(ATNType grammarType, int maxTokenType)
    {
        this.grammarType = grammarType;
        this.maxTokenType = maxTokenType;
    }

    /**
     * Compute the set of valid tokens that can occur starting in state {@code s}.
     * If {@code ctx} is null, the set of tokens will not include what can follow
     * the rule surrounding {@code s}. In other words, the set will be
     * restricted to tokens reachable staying within {@code s}'s rule.
     */
    public IntervalSet nextTokens(ATNState s, RuleContext ctx)
    {
        LL1Analyzer anal = new LL1Analyzer(this);
        IntervalSet next = anal.LOOK(s, ctx);
        return next;
    }

    /**
     * Compute the set of valid tokens that can occur starting in {@code s} and
     * staying in same rule. {@link Token#EPSILON} is in set if we reach end of
     * rule.
     */
    public IntervalSet nextTokens(ATNState s)
    {
        debug {
            import std.stdio;
            writefln("ATN: nextTokens(ATNState s) %s", s);
        }
        if (s.nextTokenWithinRule !is null ) {
            return s.nextTokenWithinRule;
        }
        s.nextTokenWithinRule = nextTokens(s, null);
        s.nextTokenWithinRule.setReadonly(true);
        return s.nextTokenWithinRule;
    }

    public void addState(ATNState state)
    {
        if (state) {
            state.atn = this;
            state.stateNumber = to!int(states.length);
        }
        states ~= state;
    }

    public void removeState(ATNState state)
    {
        states[state.stateNumber] = null; // just free mem, don't shift states in list
    }

    public int defineDecisionState(DecisionState s)
    {
        decisionToState ~= s;
        s.decision = to!int(decisionToState.length)-1;
        return s.decision;
    }

    public DecisionState getDecisionState(int decision)
    {
        if (decisionToState.length > 0) {
            return decisionToState[decision];
        }
        return null;
    }

    public int getNumberOfDecisions()
    {
        return to!int(decisionToState.length);
    }

    /**
     * Computes the set of input symbols which could follow ATN state number
     * {@code stateNumber} in the specified full {@code context}. This method
     * considers the complete parser context, but does not evaluate semantic
     * predicates (i.e. all predicates encountered during the calculation are
     * assumed true). If a path in the ATN exists from the starting state to the
     * {@link RuleStopState} of the outermost context without matching any
     * symbols, {@link Token#EOF} is added to the returned set.
     *
     * <p>If {@code context} is {@code null}, it is treated as
     * {@link ParserRuleContext#EMPTY}.</p>
     *
     *  @param stateNumber the ATN state number
     *  @param context the full parse context
     *  @return The set of potentially valid input symbols which could follow the
     *  specified state in the specified context.
     *  @throws IllegalArgumentException if the ATN does not contain a state with
     *  number {@code stateNumber}
     */
    public IntervalSet getExpectedTokens(int stateNumber, RuleContext context)
    {
        if (stateNumber < 0 || stateNumber >= states.length) {
            throw new IllegalArgumentException("Invalid state number.");
        }

        RuleContext ctx = context;
        ATNState s = states[stateNumber];
        IntervalSet following = nextTokens(s);
        if (!following.contains(TokenConstantDefinition.EPSILON)) {
            return following;
        }

        IntervalSet expected = new IntervalSet();
        expected.addAll(following);
        expected.remove(TokenConstantDefinition.EPSILON);
        while (ctx !is null && ctx.invokingState >= 0 && following.contains(TokenConstantDefinition.EPSILON)) {
            ATNState invokingState = states[ctx.invokingState];
            RuleTransition rt = cast(RuleTransition)invokingState.transition(0);
            following = nextTokens(rt.followState);
            expected.addAll(following);
            expected.remove(TokenConstantDefinition.EPSILON);
            ctx = ctx.parent;
        }

        if (following.contains(TokenConstantDefinition.EPSILON)) {
            expected.add(TokenConstantDefinition.EOF);
        }

        return expected;
    }

}
